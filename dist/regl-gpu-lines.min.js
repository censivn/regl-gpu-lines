!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).reglLines=t()}(this,(function(){"use strict";var n={CAP_START:0,CAP_END:1,CAP_SHORT:2};const t=n;var e=`\n#ifndef PI\n#define PI ${Math.PI}\n#endif\n#define CAP_START ${t.CAP_START}.0\n#define CAP_END ${t.CAP_END}.0\nfloat miterExtension(vec2 t01,vec2 t12){float cosTheta=dot(t01,t12);if(cosTheta-1e-7<-1.0)return 0.0;float sinTheta=t01.x*t12.y-t01.y*t12.x;return sinTheta/(1.0+cosTheta);}\nbool isnan(float val){return(val<0.0||0.0<val||val==0.0)?false:true;}\nbool invalid(vec4 p){return p.w==0.0||isnan(p.x);}\nbool isSelfIntersection(vec2 tBC,vec2 tCD,float widthC,float lBCD){if(dot(tBC,tCD)>0.0)return false;return length(tBC+tCD)*lBCD<2.0*widthC;}`;const i=e;var o=function({regl:n,frag:t,meta:e,segmentSpec:o,indexAttributes:r,debug:s}){return n({vert:`${e.glsl}\nattribute vec2 linePosition;${o.glsl}\nuniform float miterLimit;uniform vec2 resolution;varying vec2 lineCoord;varying float computedWidth;${s?"attribute float index;":""}\n${s?"attribute float debugInstanceID;":""}\n${s?"varying vec2 triStripGridCoord;":""}\n${s?"varying float instanceID;":""}\n${i}\nvoid main(){${s?"instanceID=debugInstanceID;":""}\n${s?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord.x=0.0;lineCoord.y=linePosition.y;vec4 pA=${e.position.generate("A")};vec4 pB=${e.position.generate("B")};vec4 pC=${e.position.generate("C")};vec4 pD=${e.position.generate("D")};if(pA.w==0.0||pB.w==0.0||pC.w==0.0||pD.w==0.0||\nisnan(pA.x)||isnan(pB.x)||isnan(pC.x)||isnan(pD.x)){gl_Position=vec4(0);return;}\nfloat _computedWidthB=${e.width.generate("B")};float _computedWidthC=${e.width.generate("C")};computedWidth=_computedWidthC;float useC=1.0;float pBw=pB.w;float computedW=pC.w;pA=vec4(pA.xy*resolution,pA.zw)/pA.w;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}\nvec2 rAB=pB.xy-pA.xy;vec2 rBC=pC.xy-pB.xy;vec2 rCD=pD.xy-pC.xy;float lAB=length(rAB);float lBC=length(rBC);float lCD=length(rCD);vec2 tAB=rAB/lAB;vec2 tBC=rBC/lBC;vec2 tCD=rCD/lCD;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 nCD=vec2(-tCD.y,tCD.x);gl_Position=pC;float dirC=dot(tBC,nCD)<0.0?-1.0:1.0;if(linePosition.x>1.0){gl_Position.xy+=dirC*linePosition.y*computedWidth*nCD;lineCoord.y=dirC;} else {bool isStart=linePosition.x<0.5;if(isStart){useC=0.0;computedWidth=_computedWidthB;computedW=pBw;}\nfloat m=miterExtension(isStart?tAB:tBC,isStart?tBC:tCD);float lABC=min(lAB,lBC);float lBCD=min(lBC,lCD);float m0_abc=min(-m*computedWidth,lABC);float m1_abc=min(m*computedWidth,lABC);float m0_bcd=min(-m*computedWidth,lBCD);float m1_bcd=min(m*computedWidth,lBCD);gl_Position.xy+=linePosition.y*computedWidth*nBC;if(isStart){gl_Position.z=pB.z;float dirB=dot(tAB,nBC)<0.0?-1.0:1.0;bool bIsOuter=dirB*linePosition.y>0.0;gl_Position.xy-=tBC*(lBC-(linePosition.y<0.0?m0_abc:m1_abc)*(bIsOuter?0.0:1.0));} else {bool cIsOuter=dirC*linePosition.y>0.0;bool clipC=abs(m)>miterLimit;gl_Position.xy-=tBC*(linePosition.y>0.0?m1_bcd:m0_bcd)*(cIsOuter && clipC?0.0:1.0);}\n}\n${[...e.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\ngl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:t,attributes:{...r,...o.attrs,linePosition:{buffer:[[0,1],[0,-1],[1,1],[1,-1],[2,1]],divisor:0}},uniforms:{miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:5})};const r=n,s=e;var a=function({regl:n,frag:t,meta:e,endpointSpec:i,indexPrimitive:o,indexAttributes:a,debug:l}){return n({vert:`${e.glsl}\nattribute float index;${i.glsl}\nuniform float miterLimit,capResolution2;uniform vec2 resolution,capScale;${e.orientation?"":"uniform float uOrientation;"}\nvarying vec2 lineCoord;varying float computedWidth;${l?"varying vec2 triStripGridCoord;":""}\n${l?"varying float instanceID;":""}\n${s}\nvoid main(){${l?"instanceID=-1.0;":""}\n${l?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord=vec2(0);float orientation=${e.orientation?e.orientation.generate(""):"mod(uOrientation,2.0)"};vec4 pB=${e.position.generate("B")};vec4 pC=${e.position.generate("C")};vec4 pD=${e.position.generate("D")};float widthB=${e.width.generate("B")};float widthC=${e.width.generate("C")};computedWidth=widthC;float useC=1.0;float pBw=pB.w;float computedW=pC.w;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(pB.w==0.0||pC.w==0.0||pD.w==0.0){gl_Position=vec4(0);return;}\nif(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}\nvec2 rBC=pC.xy-pB.xy;float lBC=length(rBC);vec2 tBC=rBC/lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 rCD=pD.xy-pC.xy;float lCD=length(rCD);vec2 tCD=rCD/lCD;vec2 nCD=vec2(-tCD.y,tCD.x);gl_Position=pC;float dirC=dot(tBC,nCD)<0.0?-1.0:1.0;float endSign=orientation==CAP_START?1.0:-1.0;float i=index;float iLast=capResolution2+4.0;if(dirC>0.0)i=iLast-i;vec2 xy=vec2(0);mat2 xyBasis=mat2(0);if(i<=capResolution2){gl_Position=pB;computedWidth=widthB;computedW=pBw;useC=0.0;if(mod(i,2.0)==0.0){xyBasis=mat2(-tBC,nBC*dirC);float theta=i/capResolution2*PI;lineCoord=vec2(sin(theta),cos(theta));if(abs(lineCoord.x)>0.1)lineCoord*=capScale;gl_Position.xy+=computedWidth*(xyBasis*lineCoord);lineCoord.y*=dirC*endSign;}\n} else {i-=capResolution2+1.0;vec2 position;if(i==0.0)position=vec2(0,1);if(i==1.0)position=vec2(1,-1);if(i>=2.0)position=vec2(1,1);if(i==3.0 && orientation==CAP_START)position=vec2(2,1);position.y*=dirC;lineCoord.y=position.y*endSign;if(position.x>1.0){gl_Position.xy+=position.y*computedWidth*nCD;} else {bool isSegmentStart=position.x<0.5;if(isSegmentStart){computedWidth=widthB;computedW=pBw;useC=0.0;gl_Position=pB;}\ngl_Position.xy+=position.y*computedWidth*nBC;if(!isSegmentStart){float m=miterExtension(tBC,tCD);float lBCD=min(lBC,lCD);float m0=min(-m*computedWidth,lBCD);float m1=min(m*computedWidth,lBCD);bool cIsOuter=dirC*position.y>0.0;bool clipC=abs(m)>miterLimit;gl_Position.xy-=tBC*(position.y>0.0?m1:m0)*(cIsOuter &&(clipC||orientation==CAP_END)?0.0:1.0);}\n}\n}\n${[...e.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\ngl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:t,attributes:{...a,...i.attrs},uniforms:{uOrientation:n.prop("orientation"),capScale:n.prop("capScale"),capResolution2:(n,t)=>2*t.capResolution,miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:o,instances:(n,t)=>t.splitCaps?t.orientation===r.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*t.capResolution+5})};const l=e;var p=function({regl:n,meta:t,frag:e,segmentSpec:i,indexAttributes:o,debug:r}){return n({vert:`${t.glsl}\nattribute float index;${i.glsl}\nuniform float jres2;uniform vec2 resolution;varying vec2 lineCoord;${r?"attribute float debugInstanceID;":""}\n${r?"varying vec2 triStripGridCoord;":""}\n${r?"varying float instanceID;":""}\n${l}\nvoid main(){gl_PointSize=10.0;${r?"instanceID=debugInstanceID;":""}\n${r?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord=vec2(0);vec4 pA=${t.position.generate("A")};vec4 pB=${t.position.generate("B")};vec4 pC=${t.position.generate("C")};vec4 pD=${t.position.generate("D")};if(invalid(pA)||invalid(pB)||invalid(pC)||invalid(pD)){gl_Position=vec4(0);return;}\nbool isStart=index<=jres2+3.0;if(isStart){vec4 tmp;tmp=pC; pC=pB; pB=tmp;tmp=pD; pD=pA; pA=tmp;}\nfloat useC=isStart?0.0:1.0;float _computedWidthB=isStart?${t.width.generate("C")}:${t.width.generate("B")};float _computedWidthC=isStart?${t.width.generate("B")}:${t.width.generate("C")};float pBw=pB.w;float computedW=pC.w;pA=vec4(pA.xy*resolution,pA.zw)/pA.w;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}\nvec2 rBC=pC.xy-pB.xy;float lBC=length(rBC);vec2 tBC=rBC/lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 rAB=pB.xy-pA.xy;float lAB=length(rAB);vec2 tAB=rAB/lAB;vec2 rCD=vec2(pD.xy-pC.xy);float lCD=length(rCD);vec2 tCD=rCD/lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float lBCD=min(lBC,lCD);float dirB=dot(tAB,nBC)<0.0?-1.0:1.0;float dirC=dot(tBC,nCD)<=0.0?-1.0:1.0;vec2 iindex=vec2(index);float flip=dirB*dirC;if(flip<0.0){if(iindex.y==jres2+2.0)iindex-=2.0;} else {if(iindex.y==jres2+3.0)iindex-=3.0;}\nvec2 xy=vec2(0);mat2 xyBasis=mat2(0);gl_Position=pC;float dz=0.0;bool selfIntersects=isSelfIntersection(nBC,nCD,_computedWidthC,lBCD);if(iindex.y<jres2+1.0||iindex.y>=jres2+5.0){vec2 miterNormal=0.5*(tCD+tBC);float miterNormalLen=length(miterNormal);bool isDegenerate=miterNormalLen==0.0;vec2 xBasis=isDegenerate?nBC:miterNormal/miterNormalLen;vec2 yBasis=vec2(-xBasis.y,xBasis.x);if(isDegenerate && !isStart)xBasis=-xBasis;xyBasis=mat2(xBasis,yBasis);if(!isStart)iindex.x=2.0*jres2+4.0-iindex.x+1.0;if(mod(iindex.x,2.0)==0.0){lineCoord.y=isStart?-dirC:dirC;float cosTheta=clamp(dot(nBC,nCD),-1.0,1.0);float theta=-0.5*dirC*acos(cosTheta)*(iindex.x/jres2);xy=dirC*vec2(sin(theta),cos(theta));//if(!isDegenerate)\ndz=-(pB.z-pC.z)*clamp(xy.x*_computedWidthC/lBC,-0.5,0.5);}\n} else {float y=iindex.x==1.0?dirC:-dirC;lineCoord.y=isStart?dirC:-dirC;float mB=miterExtension(tAB,tBC)*_computedWidthB;float mC=miterExtension(tBC,tCD)*_computedWidthC;float lABC=min(lAB,lBC);float abcClip=selfIntersects?lABC:lBC;float bcdClip=selfIntersects?lBCD:lBC;float mB0=dirB>0.0?min(abcClip,-mB):0.0;float mC0=dirC>0.0?min(bcdClip,-mC):0.0;float mB1=dirB>0.0?0.0:min(abcClip,mB);float mC1=dirC>0.0?0.0:min(bcdClip,mC);xyBasis=mat2(tBC,nBC);bool isStart=iindex.x<2.0;xy=vec2(\n(isStart?\n(y>0.0?mB1:mB0)-lBC:\n-(y>0.0?mC1:mC0)\n),\ny);if(lBC>0.0)useC=clamp(useC-dirC*xy.x/lBC*lineCoord.y,0.0,1.0);xy.x/=_computedWidthC;}\n${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\nif(selfIntersects)gl_Position.z=mix(pB.z,pC.z,isStart?1.0-useC:useC);gl_Position.z+=dz;gl_Position.xy+=_computedWidthC*(xyBasis*xy);gl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:e,attributes:{index:{buffer:[...Array(400).keys()],divisor:0},...o,...i.attrs},uniforms:{jres2:(n,t)=>2*t.joinResolution},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:(n,t)=>4*t.joinResolution+6})};const c=n,d=e;var C=function({regl:n,meta:t,frag:e,endpointSpec:i,indexAttributes:o,debug:r}){return n({vert:`${t.glsl}\nattribute float index;${i.glsl}\nuniform float joinResolution,capResolution2;uniform vec2 resolution,capScale;${t.orientation?"":"uniform float uOrientation;"}\nvarying vec2 lineCoord;varying float computedWidth;${r?"varying vec2 triStripGridCoord;":""}\n${r?"varying float instanceID;":""}\n${d}\nvoid main(){${r?"instanceID=-1.0;":""}\n${r?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord=vec2(0);float orientation=${t.orientation?t.orientation.generate(""):"mod(uOrientation,2.0)"};vec4 pB=${t.position.generate("B")};vec4 pC=${t.position.generate("C")};vec4 pD=${t.position.generate("D")};if(pB.w==0.0||pC.w==0.0||pD.w==0.0){gl_Position=vec4(0);return;}\nfloat widthB=${t.width.generate("B")};float widthC=${t.width.generate("C")};computedWidth=widthC;float pBw=pB.w;float computedW=pC.w;float useC=1.0;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}\nvec2 rBC=pC.xy-pB.xy;float lBC=length(rBC);vec2 tBC=rBC/lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 rCD=pD.xy-pC.xy;float lCD=length(rCD);vec2 tCD=rCD/lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float lBCD=min(lBC,lCD);float dirC=dot(tBC,nCD)<0.0?-1.0:1.0;float i=index;float iLast=joinResolution*2.0+capResolution2+4.0;vec2 xy=vec2(0);mat2 xyBasis=mat2(0);float dz=0.0;bool selfIntersects=isSelfIntersection(tBC,tCD,computedWidth,lBCD);if(i<capResolution2+1.0){i-=capResolution2;gl_Position=pB;computedWidth=widthB;useC=0.0;computedW=pBw;if(mod(i,2.0)==1.0){lineCoord=vec2(0);} else {mat2 xyBasis=mat2(tBC,nBC);xyBasis=mat2(tBC,nBC);float theta=i/capResolution2*PI;xy=vec2(sin(theta),-cos(theta)*dirC);if(abs(xy.x)>0.1)xy*=capScale;lineCoord=xy;gl_Position.xy+=computedWidth*(xyBasis*xy);}\n} else {i-=capResolution2;iLast=joinResolution*2.0+4.0;gl_Position=pC;bool isSegment=i<=2.0||i==iLast;if(i<=2.0||i==iLast){lineCoord.y=i==1.0?dirC:-dirC;float mC=miterExtension(tBC,tCD)*widthC;float bcdClip=selfIntersects?lBCD:lBC;float mC0=dirC>0.0?min(bcdClip,-mC):0.0;float mC1=dirC>0.0?0.0:min(bcdClip,mC);xyBasis=mat2(tBC,nBC);bool isStart=i<2.0;if(isStart)useC=0.0;gl_Position.z=isStart?pB.z:pC.z;xy=vec2(\n(isStart?\n-lBC:\n-(lineCoord.y>0.0?mC1:mC0)\n),\nlineCoord.y\n);if(!isStart)useC-=dirC*xy.x/lBC*lineCoord.y;xy.x/=computedWidth;} else {vec2 miterNormal=0.5*(tCD+tBC);float miterNormalLen=length(miterNormal);bool isDegenerate=miterNormalLen==0.0;vec2 xBasis=isDegenerate?nCD:miterNormal/miterNormalLen;vec2 yBasis=vec2(-xBasis.y,xBasis.x);xyBasis=mat2(xBasis,yBasis);if(mod(i,2.0)!=0.0){lineCoord.y=dirC;i=(i-3.0)*0.5;if(dirC>0.0)i=joinResolution-i;float cosTheta=clamp(dot(nBC,nCD),-1.0,1.0);float theta=0.5*acos(cosTheta)*(0.5-0.5*dirC-i/joinResolution);xy=dirC*vec2(sin(theta),cos(theta));if(!isDegenerate)dz=-(pB.z-pC.z)*clamp(xy.x*computedWidth/lBC,-0.5,0.5);}\n}\ngl_Position.xy+=computedWidth*(xyBasis*xy);}\nif(orientation==CAP_END)lineCoord=-lineCoord;${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\nif(selfIntersects)gl_Position.z=mix(pB.z,pC.z,useC);gl_Position.z+=dz;gl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:e,attributes:{...o,...i.attrs},uniforms:{joinResolution:n.prop("joinResolution"),capResolution2:(n,t)=>2*t.capResolution,uOrientation:n.prop("orientation"),capScale:n.prop("capScale")},primitive:"triangle strip",instances:(n,t)=>t.splitCaps?t.orientation===c.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*(t.joinResolution+t.capResolution)+4})};var f={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const u=f;var m=function(n){const t=[],e=n.split("\n");for(let n=0;n<e.length;n++)e[n]=e[n].replace(B,(function(n,e){return t.push(h(e)),""}));return{glsl:e.join("\n").trim(),...D(t)}};const B=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,v=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,y=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,g=/^\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,x={float:1,vec2:2,vec3:3,vec4:4};function h(n){let t;if(t=(n=n.trim()).match(v)){return{type:"attribute",dimension:x[t[1]],name:t[2]}}if(t=n.match(y)){const n=t[1],e={width:"float",position:"vec4",orientation:"bool"}[n],i=t[2],o=t[3].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t)=>`${i}(${o.map((e=>(t||"")+e+n)).join(",")})`;return{type:"property",property:n,returnType:e,name:i,inputs:o,generate:r}}if(t=n.match(g)){const n=t[1],e=t[2],i=t[3],o=t[4].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t,r)=>`${e}=${i}(${o.map((e=>`mix(${e+t},${e+r},${n})`)).join(",")});`;return{type:"varying",returnType:n,name:e,getter:i,inputs:o,generate:r}}throw new Error(`Unrecognized lines pragma:"${n}"`)}function D(n){const t=new Map,e=new Map;for(const i of n)"attribute"===i.type?(t.set(i.name,i),i.vertexUsage=u.NONE,i.endpointUsage=u.NONE):"varying"===i.type&&e.set(i.name,i);let i,o,r;for(const e of n)if("property"===e.type){switch(e.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);i=e;break;case"position":if(o)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);o=e;break;case"orientation":if(r)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);r=e;break;default:throw new Error(`Invalid pragma property "${e.property}"`)}for(const n of e.inputs)if(!t.has(n))throw new Error(`Missing attribute ${n} of property ${e.property}`)}for(const e of n)if(e.inputs)for(const n of e.inputs){const i=t.get(n);"property"!==e.type&&"varying"!==e.type||("position"===e.property?(i.vertexUsage|=u.EXTENDED,i.endpointUsage|=u.EXTENDED):"orientation"===e.property?i.endpointUsage|=u.PER_INSTANCE:(i.endpointUsage|=u.REGULAR,i.vertexUsage|=u.REGULAR))}return{varyings:e,attrs:t,width:i,position:o,orientation:r}}const b=[];b[5120]=1,b[5122]=2,b[5124]=4,b[5121]=1,b[5123]=2,b[5125]=4,b[5126]=4;var w=function(n,t,e){const i={};if(!t)return i;for(let[o,r]of n.attrs){const n=t[o];if(!(e?r.endpointUsage:r.vertexUsage))continue;const s={buffer:null,dimension:r.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!n)throw new Error(`Missing buffer for ${e?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===n._reglType)s.buffer=n,s.type=s.buffer._buffer.dtype;else{if("buffer"!==n.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'`);if(s.buffer=n.buffer,_(n,"dimension")&&n.dimension!==s.dimension)throw new Error(`Size of attribute(${n.dimension})does not match dimension specified in shader pragma(${r.dimension})`);_(n,"offset")&&(s.offset=n.offset),_(n,"type")?s.type=A[n.type]:s.type=s.buffer._buffer.dtype,_(n,"divisor")&&(s.divisor=n.divisor),_(n,"stride")&&(s.stride=n.stride)}s.bytesPerElement=$[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*r.dimension),i[o]=s}return i};const $=b,A={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126};function _(n,t){return Object.prototype.hasOwnProperty.call(n,t)}const P=[];P[1]="float",P[2]="vec2",P[3]="vec3",P[4]="vec4";var S=function(n,t,e){const i=e?["B","C","D"]:["A","B","C","D"],o=[],r={};return n.attrs.forEach(((n,s)=>{const a=e?n.endpointUsage:n.vertexUsage;if(!a)return;const l=[];function p(n,i){const o=s+i;if(l.push(o),e){const e=a&E.PER_INSTANCE?1:3;r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*((e.orientation!==W.CAP_START&&e.splitCaps?3:0)+n),stride:(n,t)=>t.buffers[s].stride*e*(t.splitCaps?2:1),divisor:(n,t)=>t.buffers[s].divisor}}else r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*n,stride:(n,t)=>t.buffers[s].stride,divisor:(n,t)=>t.buffers[s].divisor}}if(a&E.PER_INSTANCE&&p(0,""),a&E.REGULAR||a&E.EXTENDED)for(let n=0;n<i.length;n++){const t=i[n];(a&E.EXTENDED||"D"!==t&&"A"!==t)&&p(n,t)}o.push(`attribute ${R[n.dimension]} ${l.join(",")};`)})),n.varyings.forEach(((n,t)=>{o.push(`varying ${n.returnType} ${t};`)})),{glsl:o.join("\n"),attrs:r}};const E=f,R=P,W=n;const N=o,z=a,I=p,T=C,j=m,L=w,O=S,U=function(n,t,e,i){if(!n)return t;if(-1===e.indexOf(n))throw new Error(`Invalid ${i} type. Options are ${JSON.stringify(e).join(",")}.`);return n},M=n;var G=q;q.CAP_START=M.CAP_START,q.CAP_END=M.CAP_END;const k=new Set(["count","instances","attributes","elements"]);function q(n,t={}){const{vert:e=null,frag:i=null,debug:o=!1}=t,r={...t};for(const n of["vert","frag","debug"])delete r[n];const s=Object.keys(r),a=0===s.length;if(s.forEach((n=>{if(k.has(n))throw new Error(`Invalid parameter '${n}'. Parameters ${[...k].map((n=>`'${n}'`)).join(",")} may not be forwarded to regl.`)})),!e)throw new Error("Missing vertex shader,`vert`");if(!i)throw new Error("Missing fragment shader,`frag`");const l=j(e),p=O(l,n,!1),c=O(l,n,!0),d=n({uniforms:{resolution:n=>[n.viewportWidth,n.viewportHeight]}}),C=a?(n,t)=>t():n(r);let f,u;const m={};if(o){const t=16384;m.debugInstanceID={buffer:n.buffer(new Uint16Array([...Array(t).keys()])),divisor:1}}u="triangle strip",f=n.buffer(new Int8Array([...Array(124).keys()])),m.index={buffer:f,divisor:0};const B={regl:n,meta:l,segmentSpec:p,endpointSpec:c,frag:i,indexBuffer:f,indexPrimitive:"triangle strip",indexAttributes:m,debug:o},v=N(B),y=z(B),g=I(B),x=T(B),h=["round","bevel","miter"],D=["round","square","none"],b=[1,1],w=[2/Math.sqrt(3),2];return function(n){if(!n)return;const t=Array.isArray(n);t||(n=[n]);const e=a&&!t,i=[],o=[],r=[],s=[];function p(n){C(n,(()=>{i.length&&g(i),r.length&&v(r),o.length&&x(o),s.length&&y(s),i.length=0,r.length=0,o.length=0,s.length=0}))}d((()=>{for(const t of n){const n=L(l,t.vertexAttributes,!1),a=L(l,t.endpointAttributes,!0),c=U(t.join,"miter",h,"join"),d=U(t.cap,"square",D,"cap"),C=void 0===t.joinResolution?8:t.joinResolution;let f=void 0===t.capResolution?12:2*t.capResolution;"square"===d?f=3:"none"===d&&(f=1);const u="bevel"===c?1:void 0===t.miterLimit?4:t.miterLimit,m="square"===d?w:b;let B,v;if(t.endpointAttributes&&(B={buffers:a,count:t.endpointCount,joinResolution:C,capResolution:f,capScale:m,miterLimit:u}),t.vertexAttributes&&(v={buffers:n,count:t.vertexCount,joinResolution:C,capResolution:f,miterLimit:u}),v){("round"===c?i:r).push(v)}if(B){const n="round"===c?o:s;l.orientation?n.push({...B,splitCaps:!1}):n.push({...B,orientation:M.CAP_START,splitCaps:!0},{...B,orientation:M.CAP_END,splitCaps:!0})}e||p(t)}e&&p(n)}))}}return G}));