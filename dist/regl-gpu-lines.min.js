!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).reglLines=t()}(this,(function(){"use strict";var n={CAP_START:0,CAP_END:1,CAP_SHORT:2};const t=n;var e=`\n#ifndef PI\n#define PI ${Math.PI}\n#endif\n#define CAP_START ${t.CAP_START}.0\n#define CAP_END ${t.CAP_END}.0\nfloat miterExtension(vec2 t01,vec2 t12){\nfloat cosTheta=dot(t01,t12);\nif(cosTheta-1e-7<-1.0)return 0.0;\nfloat sinTheta=t01.x*t12.y-t01.y*t12.x;\nreturn sinTheta/(1.0+cosTheta);\n}\nbool isnan(float val){\nreturn(val<0.0||0.0<val||val==0.0)?false:true;\n}\nbool invalid(vec4 p){\nreturn p.w==0.0||isnan(p.x);\n}\nbool isSelfIntersection(vec2 tBC,vec2 tCD,float widthC,float lBCD){\nif(dot(tBC,tCD)>0.0)return false;\nreturn length(tBC+tCD)*lBCD<2.0*widthC;\n}`;const i=e;var o=function({regl:n,frag:t,meta:e,segmentSpec:o,indexAttributes:r,debug:s}){return n({vert:`${e.glsl}\nattribute vec2 linePosition;\n${o.glsl}\nuniform float miterLimit;\nuniform vec2 resolution;\nvarying vec2 lineCoord;\nvarying float computedWidth;\n${s?"attribute float index;":""}\n${s?"attribute float debugInstanceID;":""}\n${s?"varying vec2 triStripGridCoord;":""}\n${s?"varying float instanceID;":""}\n${i}\nvoid main(){\n${s?"instanceID=debugInstanceID;":""}\n${s?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord.x=0.0;\nlineCoord.y=linePosition.y;\nvec4 pA=${e.position.generate("A")};\nvec4 pB=${e.position.generate("B")};\nvec4 pC=${e.position.generate("C")};\nvec4 pD=${e.position.generate("D")};\nif(pA.w==0.0||pB.w==0.0||pC.w==0.0||pD.w==0.0||\nisnan(pA.x)||isnan(pB.x)||isnan(pC.x)||isnan(pD.x)){\ngl_Position=vec4(0);\nreturn;\n}\nfloat _computedWidthB=${e.width.generate("B")};\nfloat _computedWidthC=${e.width.generate("C")};\ncomputedWidth=_computedWidthC;\nfloat useC=1.0;\nfloat pBw=pB.w;\nfloat computedW=pC.w;\npA=vec4(pA.xy*resolution,pA.zw)/pA.w;\npB=vec4(pB.xy*resolution,pB.zw)/pBw;\npC=vec4(pC.xy*resolution,pC.zw)/computedW;\npD=vec4(pD.xy*resolution,pD.zw)/pD.w;\nif(max(abs(pB.z),abs(pC.z))>1.0){\ngl_Position=vec4(0);\nreturn;\n}\nvec2 rAB=pB.xy-pA.xy;\nvec2 rBC=pC.xy-pB.xy;\nvec2 rCD=pD.xy-pC.xy;\nfloat lAB=length(rAB);\nfloat lBC=length(rBC);\nfloat lCD=length(rCD);\nvec2 tAB=rAB/lAB;\nvec2 tBC=rBC/lBC;\nvec2 tCD=rCD/lCD;\nvec2 nBC=vec2(-tBC.y,tBC.x);\nvec2 nCD=vec2(-tCD.y,tCD.x);\ngl_Position=pC;\nfloat dirC=dot(tBC,nCD)<0.0?-1.0:1.0;\nif(linePosition.x>1.0){\ngl_Position.xy+=dirC*linePosition.y*computedWidth*nCD;\nlineCoord.y=dirC;\n} else {\nbool isStart=linePosition.x<0.5;\nif(isStart){\nuseC=0.0;\ncomputedWidth=_computedWidthB;\ncomputedW=pBw;\n}\nfloat m=miterExtension(isStart?tAB:tBC,isStart?tBC:tCD);\nfloat lABC=min(lAB,lBC);\nfloat lBCD=min(lBC,lCD);\nfloat m0_abc=min(-m*computedWidth,lABC);\nfloat m1_abc=min(m*computedWidth,lABC);\nfloat m0_bcd=min(-m*computedWidth,lBCD);\nfloat m1_bcd=min(m*computedWidth,lBCD);\ngl_Position.xy+=linePosition.y*computedWidth*nBC;\nif(isStart){\ngl_Position.z=pB.z;\nfloat dirB=dot(tAB,nBC)<0.0?-1.0:1.0;\nbool bIsOuter=dirB*linePosition.y>0.0;\ngl_Position.xy-=tBC*(lBC-(linePosition.y<0.0?m0_abc:m1_abc)*(bIsOuter?0.0:1.0));\n} else {\nbool cIsOuter=dirC*linePosition.y>0.0;\nbool clipC=abs(m)>miterLimit;\ngl_Position.xy-=tBC*(linePosition.y>0.0?m1_bcd:m0_bcd)*(cIsOuter && clipC?0.0:1.0);\n}\n}\n${[...e.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\ngl_Position.xy/=resolution;\ngl_Position*=computedW;\n}`,frag:t,attributes:{...r,...o.attrs,linePosition:{buffer:[[0,1],[0,-1],[1,1],[1,-1],[2,1]],divisor:0}},uniforms:{miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:5})};const r=n,s=e;var a=function({regl:n,frag:t,meta:e,endpointSpec:i,indexPrimitive:o,indexAttributes:a,debug:l}){return n({vert:`${e.glsl}\nattribute float index;\n${i.glsl}\nuniform float miterLimit,capResolution2;\nuniform vec2 resolution,capScale;\n${e.orientation?"":"uniform float uOrientation;"}\nvarying vec2 lineCoord;\nvarying float computedWidth;\n${l?"varying vec2 triStripGridCoord;":""}\n${l?"varying float instanceID;":""}\n${s}\nvoid main(){\n${l?"instanceID=-1.0;":""}\n${l?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord=vec2(0);\nfloat orientation=${e.orientation?e.orientation.generate(""):"mod(uOrientation,2.0)"};\nvec4 pB=${e.position.generate("B")};\nvec4 pC=${e.position.generate("C")};\nvec4 pD=${e.position.generate("D")};\nfloat widthB=${e.width.generate("B")};\nfloat widthC=${e.width.generate("C")};\ncomputedWidth=widthC;\nfloat useC=1.0;\nfloat pBw=pB.w;\nfloat computedW=pC.w;\npB=vec4(pB.xy*resolution,pB.zw)/pBw;\npC=vec4(pC.xy*resolution,pC.zw)/computedW;\npD=vec4(pD.xy*resolution,pD.zw)/pD.w;\nif(pB.w==0.0||pC.w==0.0||pD.w==0.0){\ngl_Position=vec4(0);\nreturn;\n}\nif(max(abs(pB.z),abs(pC.z))>1.0){\ngl_Position=vec4(0);\nreturn;\n}\nvec2 rBC=pC.xy-pB.xy;\nfloat lBC=length(rBC);\nvec2 tBC=rBC/lBC;\nvec2 nBC=vec2(-tBC.y,tBC.x);\nvec2 rCD=pD.xy-pC.xy;\nfloat lCD=length(rCD);\nvec2 tCD=rCD/lCD;\nvec2 nCD=vec2(-tCD.y,tCD.x);\ngl_Position=pC;\nfloat dirC=dot(tBC,nCD)<0.0?-1.0:1.0;\nfloat endSign=orientation==CAP_START?1.0:-1.0;\nfloat i=index;\nfloat iLast=capResolution2+4.0;\nif(dirC>0.0)i=iLast-i;\nvec2 xy=vec2(0);\nmat2 xyBasis=mat2(0);\nif(i<=capResolution2){\ngl_Position=pB;\ncomputedWidth=widthB;\ncomputedW=pBw;\nuseC=0.0;\nif(mod(i,2.0)==0.0){\nxyBasis=mat2(-tBC,nBC*dirC);\nfloat theta=i/capResolution2*PI;\nlineCoord=vec2(sin(theta),cos(theta));\nif(abs(lineCoord.x)>0.1)lineCoord*=capScale;\ngl_Position.xy+=computedWidth*(xyBasis*lineCoord);\nlineCoord.y*=dirC*endSign;\n}\n} else {\ni-=capResolution2+1.0;\nvec2 position;\nif(i==0.0)position=vec2(0,1);\nif(i==1.0)position=vec2(1,-1);\nif(i>=2.0)position=vec2(1,1);\nif(i==3.0 && orientation==CAP_START)position=vec2(2,1);\nposition.y*=dirC;\nlineCoord.y=position.y*endSign;\nif(position.x>1.0){\ngl_Position.xy+=position.y*computedWidth*nCD;\n} else {\nbool isSegmentStart=position.x<0.5;\nif(isSegmentStart){\ncomputedWidth=widthB;\ncomputedW=pBw;\nuseC=0.0;\ngl_Position=pB;\n}\ngl_Position.xy+=position.y*computedWidth*nBC;\nif(!isSegmentStart){\nfloat m=miterExtension(tBC,tCD);\nfloat lBCD=min(lBC,lCD);\nfloat m0=min(-m*computedWidth,lBCD);\nfloat m1=min(m*computedWidth,lBCD);\nbool cIsOuter=dirC*position.y>0.0;\nbool clipC=abs(m)>miterLimit;\ngl_Position.xy-=tBC*(position.y>0.0?m1:m0)*(cIsOuter &&(clipC||orientation==CAP_END)?0.0:1.0);\n}\n}\n}\n${[...e.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\ngl_Position.xy/=resolution;\ngl_Position*=computedW;\n}`,frag:t,attributes:{...a,...i.attrs},uniforms:{uOrientation:n.prop("orientation"),capScale:n.prop("capScale"),capResolution2:(n,t)=>2*t.capResolution,miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:o,instances:(n,t)=>t.splitCaps?t.orientation===r.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*t.capResolution+5})};const l=e;var p=function({regl:n,meta:t,frag:e,segmentSpec:i,indexAttributes:o,debug:r}){return n({vert:`${t.glsl}\nattribute float index;\n${i.glsl}\nuniform float jres2;\nuniform vec2 resolution;\nvarying vec2 lineCoord;\n${r?"attribute float debugInstanceID;":""}\n${r?"varying vec2 triStripGridCoord;":""}\n${r?"varying float instanceID;":""}\n${l}\nvoid main(){\ngl_PointSize=10.0;\n${r?"instanceID=debugInstanceID;":""}\n${r?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord=vec2(0);\nvec4 pA=${t.position.generate("A")};\nvec4 pB=${t.position.generate("B")};\nvec4 pC=${t.position.generate("C")};\nvec4 pD=${t.position.generate("D")};\nif(invalid(pA)||invalid(pB)||invalid(pC)||invalid(pD)){\ngl_Position=vec4(0);\nreturn;\n}\nbool isStart=index<=jres2+3.0;\nif(isStart){\nvec4 tmp;\ntmp=pC; pC=pB; pB=tmp;\ntmp=pD; pD=pA; pA=tmp;\n}\nfloat useC=isStart?0.0:1.0;\nfloat _computedWidthB=isStart?${t.width.generate("C")}:${t.width.generate("B")};\nfloat _computedWidthC=isStart?${t.width.generate("B")}:${t.width.generate("C")};\nfloat pBw=pB.w;\nfloat computedW=pC.w;\npA=vec4(pA.xy*resolution,pA.zw)/pA.w;\npB=vec4(pB.xy*resolution,pB.zw)/pBw;\npC=vec4(pC.xy*resolution,pC.zw)/computedW;\npD=vec4(pD.xy*resolution,pD.zw)/pD.w;\nif(max(abs(pB.z),abs(pC.z))>1.0){\ngl_Position=vec4(0);\nreturn;\n}\nvec2 rBC=pC.xy-pB.xy;\nfloat lBC=length(rBC);\nvec2 tBC=rBC/lBC;\nvec2 nBC=vec2(-tBC.y,tBC.x);\nvec2 rAB=pB.xy-pA.xy;\nfloat lAB=length(rAB);\nvec2 tAB=rAB/lAB;\nvec2 rCD=vec2(pD.xy-pC.xy);\nfloat lCD=length(rCD);\nvec2 tCD=rCD/lCD;\nvec2 nCD=vec2(-tCD.y,tCD.x);\nfloat lBCD=min(lBC,lCD);\nfloat dirB=dot(tAB,nBC)<0.0?-1.0:1.0;\nfloat dirC=dot(tBC,nCD)<=0.0?-1.0:1.0;\nvec2 iindex=vec2(index);\nfloat flip=dirB*dirC;\nif(flip<0.0){\nif(iindex.y==jres2+2.0)iindex-=2.0;\n} else {\nif(iindex.y==jres2+3.0)iindex-=3.0;\n}\nvec2 xy=vec2(0);\nmat2 xyBasis=mat2(0);\ngl_Position=pC;\nfloat dz=0.0;\nbool selfIntersects=isSelfIntersection(nBC,nCD,_computedWidthC,lBCD);\nif(iindex.y<jres2+1.0||iindex.y>=jres2+5.0){\nvec2 miterNormal=0.5*(tCD+tBC);\nfloat miterNormalLen=length(miterNormal);\nbool isDegenerate=miterNormalLen==0.0;\nvec2 xBasis=isDegenerate?nBC:miterNormal/miterNormalLen;\nvec2 yBasis=vec2(-xBasis.y,xBasis.x);\nif(isDegenerate && !isStart)xBasis=-xBasis;\nxyBasis=mat2(xBasis,yBasis);\nif(!isStart)iindex.x=2.0*jres2+4.0-iindex.x+1.0;\nif(mod(iindex.x,2.0)==0.0){\nlineCoord.y=isStart?-dirC:dirC;\nfloat cosTheta=clamp(dot(nBC,nCD),-1.0,1.0);\nfloat theta=-0.5*dirC*acos(cosTheta)*(iindex.x/jres2);\nxy=dirC*vec2(sin(theta),cos(theta));\n//if(!isDegenerate)\ndz=-(pB.z-pC.z)*clamp(xy.x*_computedWidthC/lBC,-0.5,0.5);\n}\n} else {\nfloat y=iindex.x==1.0?dirC:-dirC;\nlineCoord.y=isStart?dirC:-dirC;\nfloat mB=miterExtension(tAB,tBC)*_computedWidthB;\nfloat mC=miterExtension(tBC,tCD)*_computedWidthC;\nfloat lABC=min(lAB,lBC);\nfloat abcClip=selfIntersects?lABC:lBC;\nfloat bcdClip=selfIntersects?lBCD:lBC;\nfloat mB0=dirB>0.0?min(abcClip,-mB):0.0;\nfloat mC0=dirC>0.0?min(bcdClip,-mC):0.0;\nfloat mB1=dirB>0.0?0.0:min(abcClip,mB);\nfloat mC1=dirC>0.0?0.0:min(bcdClip,mC);\nxyBasis=mat2(tBC,nBC);\nbool isStart=iindex.x<2.0;\nxy=vec2(\n(isStart?\n(y>0.0?mB1:mB0)-lBC:\n-(y>0.0?mC1:mC0)\n),\ny);\nif(lBC>0.0)useC=clamp(useC-dirC*xy.x/lBC*lineCoord.y,0.0,1.0);\nxy.x/=_computedWidthC;\n}\n${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\nif(selfIntersects)gl_Position.z=mix(pB.z,pC.z,isStart?1.0-useC:useC);\ngl_Position.z+=dz;\ngl_Position.xy+=_computedWidthC*(xyBasis*xy);\ngl_Position.xy/=resolution;\ngl_Position*=computedW;\n}`,frag:e,attributes:{index:{buffer:[...Array(400).keys()],divisor:0},...o,...i.attrs},uniforms:{jres2:(n,t)=>2*t.joinResolution},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:(n,t)=>4*t.joinResolution+6})};const c=n,d=e;var C=function({regl:n,meta:t,frag:e,endpointSpec:i,indexAttributes:o,debug:r}){return n({vert:`${t.glsl}\nattribute float index;\n${i.glsl}\nuniform float joinResolution,capResolution2;\nuniform vec2 resolution,capScale;\n${t.orientation?"":"uniform float uOrientation;"}\nvarying vec2 lineCoord;\nvarying float computedWidth;\n${r?"varying vec2 triStripGridCoord;":""}\n${r?"varying float instanceID;":""}\n${d}\nvoid main(){\n${r?"instanceID=-1.0;":""}\n${r?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}\nlineCoord=vec2(0);\nfloat orientation=${t.orientation?t.orientation.generate(""):"mod(uOrientation,2.0)"};\nvec4 pB=${t.position.generate("B")};\nvec4 pC=${t.position.generate("C")};\nvec4 pD=${t.position.generate("D")};\nif(pB.w==0.0||pC.w==0.0||pD.w==0.0){\ngl_Position=vec4(0);\nreturn;\n}\nfloat widthB=${t.width.generate("B")};\nfloat widthC=${t.width.generate("C")};\ncomputedWidth=widthC;\nfloat pBw=pB.w;\nfloat computedW=pC.w;\nfloat useC=1.0;\npB=vec4(pB.xy*resolution,pB.zw)/pBw;\npC=vec4(pC.xy*resolution,pC.zw)/computedW;\npD=vec4(pD.xy*resolution,pD.zw)/pD.w;\nif(max(abs(pB.z),abs(pC.z))>1.0){\ngl_Position=vec4(0);\nreturn;\n}\nvec2 rBC=pC.xy-pB.xy;\nfloat lBC=length(rBC);\nvec2 tBC=rBC/lBC;\nvec2 nBC=vec2(-tBC.y,tBC.x);\nvec2 rCD=pD.xy-pC.xy;\nfloat lCD=length(rCD);\nvec2 tCD=rCD/lCD;\nvec2 nCD=vec2(-tCD.y,tCD.x);\nfloat lBCD=min(lBC,lCD);\nfloat dirC=dot(tBC,nCD)<0.0?-1.0:1.0;\nfloat i=index;\nfloat iLast=joinResolution*2.0+capResolution2+4.0;\nvec2 xy=vec2(0);\nmat2 xyBasis=mat2(0);\nfloat dz=0.0;\nbool selfIntersects=isSelfIntersection(tBC,tCD,computedWidth,lBCD);\nif(i<capResolution2+1.0){\ni-=capResolution2;\ngl_Position=pB;\ncomputedWidth=widthB;\nuseC=0.0;\ncomputedW=pBw;\nif(mod(i,2.0)==1.0){\nlineCoord=vec2(0);\n} else {\nmat2 xyBasis=mat2(tBC,nBC);\nxyBasis=mat2(tBC,nBC);\nfloat theta=i/capResolution2*PI;\nxy=vec2(sin(theta),-cos(theta)*dirC);\nif(abs(xy.x)>0.1)xy*=capScale;\nlineCoord=xy;\ngl_Position.xy+=computedWidth*(xyBasis*xy);\n}\n} else {\ni-=capResolution2;\niLast=joinResolution*2.0+4.0;\ngl_Position=pC;\nbool isSegment=i<=2.0||i==iLast;\nif(i<=2.0||i==iLast){\nlineCoord.y=i==1.0?dirC:-dirC;\nfloat mC=miterExtension(tBC,tCD)*widthC;\nfloat bcdClip=selfIntersects?lBCD:lBC;\nfloat mC0=dirC>0.0?min(bcdClip,-mC):0.0;\nfloat mC1=dirC>0.0?0.0:min(bcdClip,mC);\nxyBasis=mat2(tBC,nBC);\nbool isStart=i<2.0;\nif(isStart)useC=0.0;\ngl_Position.z=isStart?pB.z:pC.z;\nxy=vec2(\n(isStart?\n-lBC:\n-(lineCoord.y>0.0?mC1:mC0)\n),\nlineCoord.y\n);\nif(!isStart)useC-=dirC*xy.x/lBC*lineCoord.y;\nxy.x/=computedWidth;\n} else {\nvec2 miterNormal=0.5*(tCD+tBC);\nfloat miterNormalLen=length(miterNormal);\nbool isDegenerate=miterNormalLen==0.0;\nvec2 xBasis=isDegenerate?nCD:miterNormal/miterNormalLen;\nvec2 yBasis=vec2(-xBasis.y,xBasis.x);\nxyBasis=mat2(xBasis,yBasis);\nif(mod(i,2.0)!=0.0){\nlineCoord.y=dirC;\ni=(i-3.0)*0.5;\nif(dirC>0.0)i=joinResolution-i;\nfloat cosTheta=clamp(dot(nBC,nCD),-1.0,1.0);\nfloat theta=0.5*acos(cosTheta)*(0.5-0.5*dirC-i/joinResolution);\nxy=dirC*vec2(sin(theta),cos(theta));\nif(!isDegenerate)dz=-(pB.z-pC.z)*clamp(xy.x*computedWidth/lBC,-0.5,0.5);\n}\n}\ngl_Position.xy+=computedWidth*(xyBasis*xy);\n}\nif(orientation==CAP_END)lineCoord=-lineCoord;\n${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\nif(selfIntersects)gl_Position.z=mix(pB.z,pC.z,useC);\ngl_Position.z+=dz;\ngl_Position.xy/=resolution;\ngl_Position*=computedW;\n}`,frag:e,attributes:{...o,...i.attrs},uniforms:{joinResolution:n.prop("joinResolution"),capResolution2:(n,t)=>2*t.capResolution,uOrientation:n.prop("orientation"),capScale:n.prop("capScale")},primitive:"triangle strip",instances:(n,t)=>t.splitCaps?t.orientation===c.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*(t.joinResolution+t.capResolution)+4})};var f={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const u=f;var m=function(n){const t=[],e=n.split("\n");for(let n=0;n<e.length;n++)e[n]=e[n].replace(B,(function(n,e){return t.push(h(e)),""}));return{glsl:e.join("\n").trim(),...D(t)}};const B=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,v=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,y=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,g=/^\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,x={float:1,vec2:2,vec3:3,vec4:4};function h(n){let t;if(t=(n=n.trim()).match(v)){return{type:"attribute",dimension:x[t[1]],name:t[2]}}if(t=n.match(y)){const n=t[1],e={width:"float",position:"vec4",orientation:"bool"}[n],i=t[2],o=t[3].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t)=>`${i}(${o.map((e=>(t||"")+e+n)).join(",")})`;return{type:"property",property:n,returnType:e,name:i,inputs:o,generate:r}}if(t=n.match(g)){const n=t[1],e=t[2],i=t[3],o=t[4].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t,r)=>`${e}=${i}(${o.map((e=>`mix(${e+t},${e+r},${n})`)).join(",")});`;return{type:"varying",returnType:n,name:e,getter:i,inputs:o,generate:r}}throw new Error(`Unrecognized lines pragma:"${n}"`)}function D(n){const t=new Map,e=new Map;for(const i of n)"attribute"===i.type?(t.set(i.name,i),i.vertexUsage=u.NONE,i.endpointUsage=u.NONE):"varying"===i.type&&e.set(i.name,i);let i,o,r;for(const e of n)if("property"===e.type){switch(e.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);i=e;break;case"position":if(o)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);o=e;break;case"orientation":if(r)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);r=e;break;default:throw new Error(`Invalid pragma property "${e.property}"`)}for(const n of e.inputs)if(!t.has(n))throw new Error(`Missing attribute ${n} of property ${e.property}`)}for(const e of n)if(e.inputs)for(const n of e.inputs){const i=t.get(n);"property"!==e.type&&"varying"!==e.type||("position"===e.property?(i.vertexUsage|=u.EXTENDED,i.endpointUsage|=u.EXTENDED):"orientation"===e.property?i.endpointUsage|=u.PER_INSTANCE:(i.endpointUsage|=u.REGULAR,i.vertexUsage|=u.REGULAR))}return{varyings:e,attrs:t,width:i,position:o,orientation:r}}const b=[];b[5120]=1,b[5122]=2,b[5124]=4,b[5121]=1,b[5123]=2,b[5125]=4,b[5126]=4;var w=function(n,t,e){const i={};if(!t)return i;for(let[o,r]of n.attrs){const n=t[o];if(!(e?r.endpointUsage:r.vertexUsage))continue;const s={buffer:null,dimension:r.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!n)throw new Error(`Missing buffer for ${e?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===n._reglType)s.buffer=n,s.type=s.buffer._buffer.dtype;else{if("buffer"!==n.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'`);if(s.buffer=n.buffer,_(n,"dimension")&&n.dimension!==s.dimension)throw new Error(`Size of attribute(${n.dimension})does not match dimension specified in shader pragma(${r.dimension})`);_(n,"offset")&&(s.offset=n.offset),_(n,"type")?s.type=A[n.type]:s.type=s.buffer._buffer.dtype,_(n,"divisor")&&(s.divisor=n.divisor),_(n,"stride")&&(s.stride=n.stride)}s.bytesPerElement=$[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*r.dimension),i[o]=s}return i};const $=b,A={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126};function _(n,t){return Object.prototype.hasOwnProperty.call(n,t)}const P=[];P[1]="float",P[2]="vec2",P[3]="vec3",P[4]="vec4";var S=function(n,t,e){const i=e?["B","C","D"]:["A","B","C","D"],o=[],r={};return n.attrs.forEach(((n,s)=>{const a=e?n.endpointUsage:n.vertexUsage;if(!a)return;const l=[];function p(n,i){const o=s+i;if(l.push(o),e){const e=a&E.PER_INSTANCE?1:3;r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*((e.orientation!==W.CAP_START&&e.splitCaps?3:0)+n),stride:(n,t)=>t.buffers[s].stride*e*(t.splitCaps?2:1),divisor:(n,t)=>t.buffers[s].divisor}}else r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*n,stride:(n,t)=>t.buffers[s].stride,divisor:(n,t)=>t.buffers[s].divisor}}if(a&E.PER_INSTANCE&&p(0,""),a&E.REGULAR||a&E.EXTENDED)for(let n=0;n<i.length;n++){const t=i[n];(a&E.EXTENDED||"D"!==t&&"A"!==t)&&p(n,t)}o.push(`attribute ${R[n.dimension]} ${l.join(",")};`)})),n.varyings.forEach(((n,t)=>{o.push(`varying ${n.returnType} ${t};`)})),{glsl:o.join("\n"),attrs:r}};const E=f,R=P,W=n;const N=o,z=a,I=p,T=C,j=m,L=w,O=S,U=function(n,t,e,i){if(!n)return t;if(-1===e.indexOf(n))throw new Error(`Invalid ${i} type. Options are ${JSON.stringify(e).join(",")}.`);return n},M=n;var G=q;q.CAP_START=M.CAP_START,q.CAP_END=M.CAP_END;const k=new Set(["count","instances","attributes","elements"]);function q(n,t={}){const{vert:e=null,frag:i=null,debug:o=!1}=t,r={...t};for(const n of["vert","frag","debug"])delete r[n];const s=Object.keys(r),a=0===s.length;if(s.forEach((n=>{if(k.has(n))throw new Error(`Invalid parameter '${n}'. Parameters ${[...k].map((n=>`'${n}'`)).join(",")} may not be forwarded to regl.`)})),!e)throw new Error("Missing vertex shader,`vert`");if(!i)throw new Error("Missing fragment shader,`frag`");const l=j(e),p=O(l,n,!1),c=O(l,n,!0),d=n({uniforms:{resolution:n=>[n.viewportWidth,n.viewportHeight]}}),C=a?(n,t)=>t():n(r);let f,u;const m={};if(o){const t=16384;m.debugInstanceID={buffer:n.buffer(new Uint16Array([...Array(t).keys()])),divisor:1}}u="triangle strip",f=n.buffer(new Int8Array([...Array(124).keys()])),m.index={buffer:f,divisor:0};const B={regl:n,meta:l,segmentSpec:p,endpointSpec:c,frag:i,indexBuffer:f,indexPrimitive:"triangle strip",indexAttributes:m,debug:o},v=N(B),y=z(B),g=I(B),x=T(B),h=["round","bevel","miter"],D=["round","square","none"],b=[1,1],w=[2/Math.sqrt(3),2];return function(n){if(!n)return;const t=Array.isArray(n);t||(n=[n]);const e=a&&!t,i=[],o=[],r=[],s=[];function p(n){C(n,(()=>{i.length&&g(i),r.length&&v(r),o.length&&x(o),s.length&&y(s),i.length=0,r.length=0,o.length=0,s.length=0}))}d((()=>{for(const t of n){const n=L(l,t.vertexAttributes,!1),a=L(l,t.endpointAttributes,!0),c=U(t.join,"miter",h,"join"),d=U(t.cap,"square",D,"cap"),C=void 0===t.joinResolution?8:t.joinResolution;let f=void 0===t.capResolution?12:2*t.capResolution;"square"===d?f=3:"none"===d&&(f=1);const u="bevel"===c?1:void 0===t.miterLimit?4:t.miterLimit,m="square"===d?w:b;let B,v;if(t.endpointAttributes&&(B={buffers:a,count:t.endpointCount,joinResolution:C,capResolution:f,capScale:m,miterLimit:u}),t.vertexAttributes&&(v={buffers:n,count:t.vertexCount,joinResolution:C,capResolution:f,miterLimit:u}),v){("round"===c?i:r).push(v)}if(B){const n="round"===c?o:s;l.orientation?n.push({...B,splitCaps:!1}):n.push({...B,orientation:M.CAP_START,splitCaps:!0},{...B,orientation:M.CAP_END,splitCaps:!0})}e||p(t)}e&&p(n)}))}}return G}));