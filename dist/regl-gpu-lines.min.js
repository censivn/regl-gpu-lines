!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).reglLines=t()}(this,(function(){"use strict";var n={CAP_START:0,CAP_END:1,CAP_SHORT:2};const t=n;var e=`\n#ifndef PI\n#define PI ${Math.PI}\n#endif\n\n#define CAP_START ${t.CAP_START}.0\n#define CAP_END ${t.CAP_END}.0\n\nfloat miterExtension(vec2 t01, vec2 t12) {\n  float cosTheta = dot(t01, t12);\n  if (cosTheta - 1e-7 < -1.0) return 0.0;\n  float sinTheta = t01.x * t12.y - t01.y * t12.x;\n  return sinTheta / (1.0 + cosTheta);\n}\n\nbool isnan(float val) {\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nbool invalid(vec4 p) {\n  return p.w==0.0||isnan(p.x);\n}\n\nbool isSelfIntersection(vec2 tBC, vec2 tCD, float widthC, float lBCD) {\n  if (dot(tBC, tCD) > 0.0) return false;\n  return length(tBC + tCD) * lBCD < 2.0 * widthC;\n}`;const i=e;var o=function({regl:n,meta:t,frag:e,segmentSpec:o,indexAttributes:r,debug:s}){return n({vert:`${t.glsl}\n\nattribute float index;\n${o.glsl}\n\nuniform float jres2;\nuniform vec2 resolution;\n\nvarying vec2 lineCoord;\n\n${s?"attribute float debugInstanceID;":""}\n${s?"varying vec2 triStripGridCoord;":""}\n${s?"varying float instanceID;":""}\n\n${i}\n\nvoid main() {\n  gl_PointSize = 10.0;\n  ${s?"instanceID = debugInstanceID;":""}\n  ${s?"triStripGridCoord = vec2(floor(index / 2.0), mod(index, 2.0));":""}\n\n  lineCoord = vec2(0);\n\n  // Project all four points\n  vec4 pA = ${t.position.generate("A")};\n  vec4 pB = ${t.position.generate("B")};\n  vec4 pC = ${t.position.generate("C")};\n  vec4 pD = ${t.position.generate("D")};\n\n  if (invalid(pA) || invalid(pB) || invalid(pC) || invalid(pD)) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  \n  bool isStart = index <= jres2 + 3.0;\n  if (isStart) {\n    vec4 tmp;\n    tmp = pC; pC = pB; pB = tmp;\n    tmp = pD; pD = pA; pA = tmp;\n  }\n\n  float useC = isStart ? 0.0 : 1.0;\n  float _computedWidthB = isStart ? ${t.width.generate("C")} : ${t.width.generate("B")};\n  float _computedWidthC = isStart ? ${t.width.generate("B")} : ${t.width.generate("C")};\n\n  float pBw = pB.w;\n  float computedW = pC.w;\n\n  \n  pA = vec4(pA.xy * resolution, pA.zw) / pA.w;\n  pB = vec4(pB.xy * resolution, pB.zw) / pBw;\n  pC = vec4(pC.xy * resolution, pC.zw) / computedW;\n  pD = vec4(pD.xy * resolution, pD.zw) / pD.w;\n\n  \n  if (max(abs(pB.z), abs(pC.z)) > 1.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  \n  vec2 rBC = pC.xy - pB.xy;\n  float lBC = length(rBC);\n  vec2 tBC = rBC / lBC;\n  vec2 nBC = vec2(-tBC.y, tBC.x);\n\n  vec2 rAB = pB.xy - pA.xy;\n  float lAB = length(rAB);\n  vec2 tAB = rAB / lAB;\n\n  vec2 rCD = vec2(pD.xy - pC.xy);\n  float lCD = length(rCD);\n  vec2 tCD = rCD / lCD;\n  vec2 nCD = vec2(-tCD.y, tCD.x);\n\n  float lBCD = min(lBC, lCD);\n\n  \n  float dirB = dot(tAB, nBC) < 0.0 ? -1.0 : 1.0;\n  float dirC = dot(tBC, nCD) <= 0.0 ? -1.0 : 1.0;\n\n  \n  vec2 iindex = vec2(index);\n\n  float flip = dirB * dirC;\n  if (flip < 0.0) {\n    if (iindex.y == jres2 + 2.0) iindex -= 2.0;\n  } else {\n    if (iindex.y == jres2 + 3.0) iindex -= 3.0;\n  }\n\n  vec2 xy = vec2(0);\n  mat2 xyBasis = mat2(0);\n\n  gl_Position = pC;\n  float dz = 0.0;\n\n  bool selfIntersects = isSelfIntersection(nBC, nCD, _computedWidthC, lBCD);\n\n  if (iindex.y < jres2 + 1.0 || iindex.y >= jres2 + 5.0) {\n    vec2 miterNormal = 0.5 * (tCD + tBC);\n    float miterNormalLen = length(miterNormal);\n    bool isDegenerate = miterNormalLen == 0.0;\n\n    vec2 xBasis = isDegenerate ? nBC : miterNormal / miterNormalLen;\n    vec2 yBasis = vec2(-xBasis.y, xBasis.x);\n    if (isDegenerate && !isStart) xBasis = -xBasis;\n    xyBasis = mat2(xBasis, yBasis);\n\n    \n    if (!isStart) iindex.x = 2.0 * jres2 + 4.0 - iindex.x + 1.0;\n\n    \n    if (mod(iindex.x, 2.0) == 0.0) {\n      lineCoord.y = isStart ? -dirC : dirC;\n      float cosTheta = clamp(dot(nBC, nCD), -1.0, 1.0);\n      float theta = -0.5 * dirC * acos(cosTheta) * (iindex.x / jres2);\n      xy = dirC * vec2(sin(theta), cos(theta));\n\n      \n      //if (!isDegenerate)\n        dz = -(pB.z - pC.z) * clamp(xy.x * _computedWidthC / lBC, -0.5, 0.5);\n    }\n  } else {\n    \n    \n    float y = iindex.x == 1.0 ? dirC : -dirC;\n\n    lineCoord.y = isStart ? dirC : -dirC;\n\n    // Extension of miter tangent to the segment\n    float mB = miterExtension(tAB, tBC) * _computedWidthB;\n    float mC = miterExtension(tBC, tCD) * _computedWidthC;\n\n    \n    float lABC = min(lAB, lBC);\n    float abcClip = selfIntersects ? lABC : lBC;\n    float bcdClip = selfIntersects ? lBCD : lBC;\n    float mB0 = dirB > 0.0 ? min(abcClip, -mB) : 0.0;\n    float mC0 = dirC > 0.0 ? min(bcdClip, -mC) : 0.0;\n    float mB1 = dirB > 0.0 ? 0.0 : min(abcClip, mB);\n    float mC1 = dirC > 0.0 ? 0.0 : min(bcdClip, mC);\n\n    xyBasis = mat2(tBC, nBC);\n    bool isStart = iindex.x < 2.0;\n\n    xy = vec2(\n      (isStart ?\n        \n        (y > 0.0 ? mB1 : mB0) - lBC :\n        \n        -(y > 0.0 ? mC1 : mC0)\n      ),\n      y);\n\n    if (lBC > 0.0) useC = clamp(useC - dirC * xy.x / lBC * lineCoord.y, 0.0, 1.0);\n\n    xy.x /= _computedWidthC;\n  }\n\n  \n  ${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\n\n  \n  if (selfIntersects) gl_Position.z = mix(pB.z, pC.z, isStart ? 1.0 - useC : useC);\n\n  // Compute the final position\n  gl_Position.z += dz;\n  gl_Position.xy += _computedWidthC * (xyBasis * xy);\n  gl_Position.xy /= resolution;\n  gl_Position *= computedW;\n}`,frag:e,attributes:{index:{buffer:[...Array(400).keys()],divisor:0},...r,...o.attrs},uniforms:{jres2:(n,t)=>2*t.joinResolution},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:(n,t)=>4*t.joinResolution+6})};const r=n,s=e;var a=function({regl:n,meta:t,frag:e,endpointSpec:i,indexAttributes:o,debug:a}){return n({vert:`${t.glsl}\n\nattribute float index;\n${i.glsl}\n\nuniform float joinResolution, capResolution2;\nuniform vec2 resolution, capScale;\n${t.orientation?"":"uniform float uOrientation;"}\n\nvarying vec2 lineCoord;\nvarying float computedWidth;\n\n${a?"varying vec2 triStripGridCoord;":""}\n${a?"varying float instanceID;":""}\n\n${s}\n\nvoid main() {\n  ${a?"instanceID = -1.0;":""}\n  ${a?"triStripGridCoord = vec2(floor(index / 2.0), mod(index, 2.0));":""}\n  lineCoord = vec2(0);\n\n  float orientation = ${t.orientation?t.orientation.generate(""):"mod(uOrientation,2.0)"};\n\n  // Project points\n  vec4 pB = ${t.position.generate("B")};\n  vec4 pC = ${t.position.generate("C")};\n  vec4 pD = ${t.position.generate("D")};\n\n  if (pB.w == 0.0 || pC.w == 0.0 || pD.w == 0.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  float widthB = ${t.width.generate("B")};\n  float widthC = ${t.width.generate("C")};\n  computedWidth = widthC;\n\n  float pBw = pB.w;\n  float computedW = pC.w;\n  float useC = 1.0;\n\n  // Convert to screen-pixel coordinates\n  pB = vec4(pB.xy * resolution, pB.zw) / pBw;\n  pC = vec4(pC.xy * resolution, pC.zw) / computedW;\n  pD = vec4(pD.xy * resolution, pD.zw) / pD.w;\n\n  // Invalidate triangles too far in front of or behind the camera plane\n  if (max(abs(pB.z), abs(pC.z)) > 1.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  // Tangent and normal vectors\n  vec2 rBC = pC.xy - pB.xy;\n  float lBC = length(rBC);\n  vec2 tBC = rBC / lBC;\n  vec2 nBC = vec2(-tBC.y, tBC.x);\n\n  vec2 rCD = pD.xy - pC.xy;\n  float lCD = length(rCD);\n  vec2 tCD = rCD / lCD;\n  vec2 nCD = vec2(-tCD.y, tCD.x);\n\n  float lBCD = min(lBC, lCD);\n\n  // Left/right turning at each vertex\n  // Note: don't use sign for this! It's zero when the line is straight.\n  float dirC = dot(tBC, nCD) < 0.0 ? -1.0 : 1.0;\n\n  float i = index;\n  float iLast = joinResolution * 2.0 + capResolution2 + 4.0;\n\n  vec2 xy = vec2(0);\n  mat2 xyBasis = mat2(0);\n  float dz = 0.0;\n\n  bool selfIntersects = isSelfIntersection(tBC, tCD, computedWidth, lBCD);\n\n  if (i < capResolution2 + 1.0) {\n    // The first few vertices are on the cap.\n    i -= capResolution2;\n    gl_Position = pB;\n    computedWidth = widthB;\n    useC = 0.0;\n    computedW = pBw;\n\n    if (mod(i, 2.0) == 1.0) {\n      lineCoord = vec2(0);\n    } else {\n      mat2 xyBasis = mat2(tBC, nBC);\n      xyBasis = mat2(tBC, nBC);\n      float theta = i / capResolution2 * PI;\n      xy = vec2(sin(theta), -cos(theta) * dirC);\n      if (abs(xy.x) > 0.1) xy *= capScale;\n      lineCoord = xy;\n      gl_Position.xy += computedWidth * (xyBasis * xy);\n    }\n  } else {\n    i -= capResolution2;\n    iLast = joinResolution * 2.0 + 4.0;\n\n    gl_Position = pC;\n\n    bool isSegment = i <= 2.0 || i == iLast;\n    if (i <= 2.0 || i == iLast) {\n      // We're in the miter/segment portion\n\n      // Use the turning direction to put the positive line coord on a consistent side\n      lineCoord.y = i == 1.0 ? dirC : -dirC;\n\n      // Extension of miter tangent to the segment\n      float mC = miterExtension(tBC, tCD) * widthC;\n\n      // Place the corners, with clipping against the opposite end\n      float bcdClip = selfIntersects ? lBCD : lBC;\n      float mC0 = dirC > 0.0 ? min(bcdClip, -mC) : 0.0;\n      float mC1 = dirC > 0.0 ? 0.0 : min(bcdClip, mC);\n\n      xyBasis = mat2(tBC, nBC);\n      bool isStart = i < 2.0;\n\n      if (isStart) useC = 0.0;\n\n      gl_Position.z = isStart ? pB.z : pC.z;\n\n      xy = vec2(\n        (isStart ?\n          // If so, then use the miter at B\n          -lBC :\n\n          // Else, the miter at C\n          -(lineCoord.y > 0.0 ? mC1 : mC0)\n        ),\n        lineCoord.y\n      );\n\n      if (!isStart) useC -= dirC * xy.x / lBC * lineCoord.y;\n\n      xy.x /= computedWidth;\n    } else {\n      vec2 miterNormal = 0.5 * (tCD + tBC);\n      float miterNormalLen = length(miterNormal);\n      bool isDegenerate = miterNormalLen == 0.0;\n\n      vec2 xBasis = isDegenerate ? nCD : miterNormal / miterNormalLen;\n      vec2 yBasis = vec2(-xBasis.y, xBasis.x);\n      xyBasis = mat2(xBasis, yBasis);\n\n      if (mod(i, 2.0) != 0.0) {\n        // Odd-numbered point in this range are around the arc. (Even numbered points in this\n        // range are a no-op and fall through to just point C)\n        lineCoord.y = dirC;\n\n        // Our indexing is offset by three, and every other index is just the center point\n        // pC (which we repeat a bunch since we're drawing a triangle strip)\n        i = (i - 3.0) * 0.5;\n        if (dirC > 0.0) i = joinResolution - i;\n\n        float cosTheta = clamp(dot(nBC, nCD), -1.0, 1.0);\n        float theta = 0.5 * acos(cosTheta) * (0.5 - 0.5 * dirC - i / joinResolution);\n        xy = dirC * vec2(sin(theta), cos(theta));\n\n      \n        if (!isDegenerate) dz = -(pB.z - pC.z) * clamp(xy.x * computedWidth / lBC, -0.5, 0.5);\n      }\n    }\n\n    // Compute the final position\n    gl_Position.xy += computedWidth * (xyBasis * xy);\n  }\n\n  if (orientation == CAP_END) lineCoord = -lineCoord;\n\n  \n  ${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}\n\n  \n  if (selfIntersects) gl_Position.z = mix(pB.z, pC.z, useC);\n\n  gl_Position.z += dz;\n  gl_Position.xy /= resolution;\n  gl_Position *= computedW;\n}`,frag:e,attributes:{...o,...i.attrs},uniforms:{joinResolution:n.prop("joinResolution"),capResolution2:(n,t)=>2*t.capResolution,uOrientation:n.prop("orientation"),capScale:n.prop("capScale")},primitive:"triangle strip",instances:(n,t)=>t.splitCaps?t.orientation===r.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*(t.joinResolution+t.capResolution)+4})};var l={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const p=l;var f=function(n){const t=[],e=n.split("\n");for(let n=0;n<e.length;n++)e[n]=e[n].replace(c,(function(n,e){return t.push(v(e)),""}));return{glsl:e.join("\n").trim(),...g(t)}};const c=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,d=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,u=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,C=/^\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,m={float:1,vec2:2,vec3:3,vec4:4};function v(n){let t;if(t=(n=n.trim()).match(d)){return{type:"attribute",dimension:m[t[1]],name:t[2]}}if(t=n.match(u)){const n=t[1],e={width:"float",position:"vec4",orientation:"bool"}[n],i=t[2],o=t[3].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t)=>`${i}(${o.map((e=>(t||"")+e+n)).join(", ")})`;return{type:"property",property:n,returnType:e,name:i,inputs:o,generate:r}}if(t=n.match(C)){const n=t[1],e=t[2],i=t[3],o=t[4].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t,r)=>`${e} = ${i}(${o.map((e=>`mix(${e+t}, ${e+r}, ${n})`)).join(", ")});`;return{type:"varying",returnType:n,name:e,getter:i,inputs:o,generate:r}}throw new Error(`Unrecognized lines pragma: "${n}"`)}function g(n){const t=new Map,e=new Map;for(const i of n)"attribute"===i.type?(t.set(i.name,i),i.vertexUsage=p.NONE,i.endpointUsage=p.NONE):"varying"===i.type&&e.set(i.name,i);let i,o,r;for(const e of n)if("property"===e.type){switch(e.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);i=e;break;case"position":if(o)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);o=e;break;case"orientation":if(r)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);r=e;break;default:throw new Error(`Invalid pragma property "${e.property}"`)}for(const n of e.inputs)if(!t.has(n))throw new Error(`Missing attribute ${n} of property ${e.property}`)}for(const e of n)if(e.inputs)for(const n of e.inputs){const i=t.get(n);"property"!==e.type&&"varying"!==e.type||("position"===e.property?(i.vertexUsage|=p.EXTENDED,i.endpointUsage|=p.EXTENDED):"orientation"===e.property?i.endpointUsage|=p.PER_INSTANCE:(i.endpointUsage|=p.REGULAR,i.vertexUsage|=p.REGULAR))}return{varyings:e,attrs:t,width:i,position:o,orientation:r}}const y=[];y[5120]=1,y[5122]=2,y[5124]=4,y[5121]=1,y[5123]=2,y[5125]=4,y[5126]=4;var B=function(n,t,e){const i={};if(!t)return i;for(let[o,r]of n.attrs){const n=t[o];if(!(e?r.endpointUsage:r.vertexUsage))continue;const s={buffer:null,dimension:r.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!n)throw new Error(`Missing buffer for ${e?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===n._reglType)s.buffer=n,s.type=s.buffer._buffer.dtype;else{if("buffer"!==n.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'`);if(s.buffer=n.buffer,b(n,"dimension")&&n.dimension!==s.dimension)throw new Error(`Size of attribute (${n.dimension}) does not match dimension specified in shader pragma (${r.dimension})`);b(n,"offset")&&(s.offset=n.offset),b(n,"type")?s.type=x[n.type]:s.type=s.buffer._buffer.dtype,b(n,"divisor")&&(s.divisor=n.divisor),b(n,"stride")&&(s.stride=n.stride)}s.bytesPerElement=h[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*r.dimension),i[o]=s}return i};const h=y,x={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126};function b(n,t){return Object.prototype.hasOwnProperty.call(n,t)}const D=[];D[1]="float",D[2]="vec2",D[3]="vec3",D[4]="vec4";var w=function(n,t,e){const i=e?["B","C","D"]:["A","B","C","D"],o=[],r={};return n.attrs.forEach(((n,s)=>{const a=e?n.endpointUsage:n.vertexUsage;if(!a)return;const l=[];function p(n,i){const o=s+i;if(l.push(o),e){const e=a&$.PER_INSTANCE?1:3;r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*((e.orientation!==E.CAP_START&&e.splitCaps?3:0)+n),stride:(n,t)=>t.buffers[s].stride*e*(t.splitCaps?2:1),divisor:(n,t)=>t.buffers[s].divisor}}else r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*n,stride:(n,t)=>t.buffers[s].stride,divisor:(n,t)=>t.buffers[s].divisor}}if(a&$.PER_INSTANCE&&p(0,""),a&$.REGULAR||a&$.EXTENDED)for(let n=0;n<i.length;n++){const t=i[n];(a&$.EXTENDED||"D"!==t&&"A"!==t)&&p(n,t)}o.push(`attribute ${A[n.dimension]} ${l.join(", ")};`)})),n.varyings.forEach(((n,t)=>{o.push(`varying ${n.returnType} ${t};`)})),{glsl:o.join("\n"),attrs:r}};const $=l,A=D,E=n;const _=o,P=a,S=f,N=B,R=w,T=function(n,t,e,i){if(!n)return t;if(-1===e.indexOf(n))throw new Error(`Invalid ${i} type. Options are ${JSON.stringify(e).join(", ")}.`);return n},j=n;var z=W;W.CAP_START=j.CAP_START,W.CAP_END=j.CAP_END;const I=new Set(["count","instances","attributes","elements"]);function W(n,t={}){const{vert:e=null,frag:i=null,debug:o=!1}=t,r={...t};for(const n of["vert","frag","debug"])delete r[n];const s=Object.keys(r),a=0===s.length;if(s.forEach((n=>{if(I.has(n))throw new Error(`Invalid parameter '${n}'. Parameters ${[...I].map((n=>`'${n}'`)).join(", ")} may not be forwarded to regl.`)})),!e)throw new Error("Missing vertex shader, `vert`");if(!i)throw new Error("Missing fragment shader, `frag`");const l=S(e),p=R(l,n,!1),f=R(l,n,!0),c=n({uniforms:{resolution:n=>[n.viewportWidth,n.viewportHeight]}}),d=a?(n,t)=>t():n(r);let u,C;const m={};if(o){const t=16384;m.debugInstanceID={buffer:n.buffer(new Uint16Array([...Array(t).keys()])),divisor:1}}C="triangle strip",u=n.buffer(new Int8Array([...Array(126).keys()])),m.index={buffer:u,divisor:0};const v={regl:n,meta:l,segmentSpec:p,endpointSpec:f,frag:i,indexBuffer:u,indexPrimitive:"triangle strip",indexAttributes:m,debug:o},g=_(v),y=P(v),B=["round","bevel","miter"],h=["round","square","none"],x=[1,1],b=[2/Math.sqrt(3),2];return function(n){if(!n)return;const t=Array.isArray(n);t||(n=[n]);const e=a&&!t,i=[],o=[],r=[],s=[];function p(n){d(n,(()=>{i.length&&g(i),o.length&&y(o),i.length=0,r.length=0,o.length=0,s.length=0}))}c((()=>{for(const t of n){const n=N(l,t.vertexAttributes,!1),a=N(l,t.endpointAttributes,!0),f=T(t.join,"miter",B,"join"),c=T(t.cap,"square",h,"cap"),d=void 0===t.joinResolution?8:t.joinResolution;let u=void 0===t.capResolution?12:2*t.capResolution;"square"===c?u=3:"none"===c&&(u=1);const C="bevel"===f?1:void 0===t.miterLimit?4:t.miterLimit,m="square"===c?b:x;let v,g;if(t.endpointAttributes&&(v={buffers:a,count:t.endpointCount,joinResolution:d,capResolution:u,capScale:m,miterLimit:C}),t.vertexAttributes&&(g={buffers:n,count:t.vertexCount,joinResolution:d,capResolution:u,miterLimit:C}),g){("round"===f?i:r).push(g)}if(v){const n="round"===f?o:s;l.orientation?n.push({...v,splitCaps:!1}):n.push({...v,orientation:j.CAP_START,splitCaps:!0},{...v,orientation:j.CAP_END,splitCaps:!0})}e||p(t)}e&&p(n)}))}}return z}));