!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).reglLines=n()}(this,(function(){"use strict";var e={CAP_START:0,CAP_END:1,CAP_SHORT:2};const n=e;var t=function(e,t,{regl:i,meta:r,frag:o,segmentSpec:s,endpointSpec:a,indexAttributes:p,insertCaps:f,debug:l}){const d=t?a:s,c=["B","C","D"];t||c.unshift("A");const u=f?t?e=>[e.capRes2,Math.max(e.capRes2,e.joinRes2)]:e=>[Math.max(e.capRes2,e.joinRes2),Math.max(e.capRes2,e.joinRes2)]:t?e=>[e.capRes2,e.joinRes2]:e=>[e.joinRes2,e.joinRes2];return i({vert:`${r.glsl}const float CAP_START=${n.CAP_START}.0;const float CAP_END=${n.CAP_END}.0;${d.glsl}attribute float index;${l?"attribute float debugInstanceID;":""}uniform vec2 vertCnt2,capJoinRes2;uniform vec2 resolution,capScale;uniform float miterLimit;${r.orientation||!t?"":"uniform float orientation;"}varying vec3 lineCoord;varying float dir;${l?"varying vec2 triStripCoord;":""}${l?"varying float instanceID;":""}${l?"varying float vertexIndex;":""}bool invalid(vec4 p){return p.w==0.0;}void main(){const float pi=3.141592653589793;bool isRound=${e?"true":"false"};${l?"vertexIndex=index;":""}lineCoord=vec3(0);${l?`instanceID=${t?"-1.0":"debugInstanceID"};`:""}${l?"triStripCoord=vec2(floor(index/2.0),mod(index,2.0));":""}${c.map((e=>`vec4 p${e}=${r.position.generate(e)};`)).join("\n")}gl_Position=pB;bool aInvalid=${t?"false":"invalid(pA)"};bool bInvalid=invalid(pB);bool cInvalid=invalid(pC);bool dInvalid=invalid(pD);vec2 v=vertCnt2+3.0;float N=dot(v,vec2(1));bool mirror=index>=v.x;${t?"if(dInvalid && mirror)return;":""}float pw=mirror?pC.w:pB.w;${c.map((e=>`p${e}=vec4(vec3(p${e}.xy*resolution,p${e}.z)/p${e}.w,1);`)).join("\n")}${t?"vec4 pA=pC;":""}if(bInvalid||cInvalid||max(abs(pB.z),abs(pC.z))>1.0)return;if(mirror){vec4 vTmp=pC; pC=pB; pB=vTmp;vTmp=pD; pD=pA; pA=vTmp;bool bTmp=dInvalid; dInvalid=aInvalid; aInvalid=bTmp;}${t?"bool isCap=!mirror;":(f?"":"const ")+"bool isCap=false"};if(aInvalid){ ${f?"pA=pC; isCap=true;":"pA=2.0*pB-pC;"} }if(dInvalid){ ${f?"pD=pB;":"pD=2.0*pC-pB;"} }isRound=isRound||isCap;float width=mirror?${r.width.generate("C")}:${r.width.generate("B")};vec2 tBC=pC.xy-pB.xy;float lBC=length(tBC);tBC/=lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 tAB=pB.xy-pA.xy;float lAB=length(tAB);if(lAB>0.0)tAB/=lAB;vec2 nAB=vec2(-tAB.y,tAB.x);vec2 tCD=pD.xy-pC.xy;float lCD=length(tCD);if(lCD>0.0)tCD/=lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float cosB=clamp(dot(tAB,tBC),-1.0,1.0);const float tol=1e-4;float mirrorSign=mirror?-1.0:1.0;float dirB=-dot(tBC,nAB);float dirC=dot(tBC,nCD);bool bCollinear=abs(dirB)<tol;bool cCollinear=abs(dirC)<tol;bool bIsHairpin=bCollinear && cosB<0.0;dirB=bCollinear?-mirrorSign:sign(dirB);dirC=cCollinear?-mirrorSign:sign(dirC);vec2 miter=bIsHairpin?-tBC:0.5*(nAB+nBC)*dirB;float i=mirror?N-index:index;float res=(isCap?capJoinRes2.x:capJoinRes2.y);i-=max(0.0,(mirror?vertCnt2.y:vertCnt2.x)-res);i+=(dirB<0.0?-1.0:0.0);i-=mirror?1.0:0.0;i=max(0.0,i);vec2 xBasis=tBC;vec2 yBasis=nBC*dirB;vec2 xy=vec2(0);lineCoord.y=dirB*mirrorSign;if(i==res+1.0){float m=cosB>-0.9999?(tAB.x*tBC.y-tAB.y*tBC.x)/(1.0+cosB):0.0;xy=vec2(min(abs(m),min(lBC,lAB)/width),-1);lineCoord.y=-lineCoord.y;} else {float m2=dot(miter,miter);float lm=sqrt(m2);yBasis=miter/lm;xBasis=dirB*vec2(yBasis.y,-yBasis.x);bool isBevel=1.0>miterLimit*m2;if(mod(i,2.0)==0.0){if(isRound||i !=0.0){float theta=-0.5*(acos(cosB)*(clamp(i,0.0,res)/res)-pi)*(isCap?2.0:1.0);xy=vec2(cos(theta),sin(theta));if(isCap){if(xy.y>0.001)xy*=capScale;lineCoord.xy=xy.yx*lineCoord.y;}} else {yBasis=bIsHairpin?vec2(0):miter;xy.y=isBevel?1.0:1.0/m2;}} else {lineCoord.y=0.0;if(isBevel && !isRound){xy.y=-1.0+sqrt((1.0+cosB)*0.5);}}}${t?`float orientation=${r.orientation?r.orientation.generate(""):"mod(orientation,2.0)"};`:""};${t?"if(orientation==CAP_END)lineCoord.xy=-lineCoord.xy;":""}vec2 dP=mat2(xBasis,yBasis)*xy;float dx=dot(dP,tBC)*mirrorSign;float useC=(mirror?1.0:0.0)+dx*(width/lBC);lineCoord.z=useC<0.0||useC>1.0?1.0:0.0;${[...r.varyings.values()].map((e=>e.generate("useC","B","C"))).join("\n")}gl_Position=pB;gl_Position.xy+=width*dP;gl_Position.xy/=resolution;gl_Position*=pw;}`,frag:o,attributes:{...p,...d.attrs},uniforms:{vertCnt2:(e,n)=>u(n),capJoinRes2:(e,n)=>[n.capRes2,n.joinRes2],miterLimit:(e,n)=>n.miterLimit*n.miterLimit,orientation:i.prop("orientation"),capScale:i.prop("capScale")},primitive:(e,n)=>n.primitive||"triangle strip",instances:t?(e,t)=>t.splitCaps?t.orientation===n.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count:(e,n)=>n.count-3,count:(e,n)=>{const t=u(n);return 6+(t[0]+t[1])}})};var i={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const r=i;var o=function(e){const n=[],t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=t[e].replace(s,(function(e,t){return n.push(d(t)),""}));return{glsl:t.join("\n").trim(),...c(n)}};const s=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,a=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,p=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,f=/^\s*(?:(extrapolate)?)\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,l={float:1,vec2:2,vec3:3,vec4:4};function d(e){let n;if(n=(e=e.trim()).match(a)){return{type:"attribute",dimension:l[n[1]],name:n[2]}}if(n=e.match(p)){const e=n[1],t={width:"float",position:"vec4",orientation:"bool"}[e],i=n[2],r=n[3].split(",").map((e=>e.trim())).filter((e=>!!e)),o=(e,n)=>`${i}(${r.map((t=>(n||"")+t+e)).join(",")})`;return{type:"property",property:e,returnType:t,name:i,inputs:r,generate:o}}if(n=e.match(f)){const e="extrapolate"===n[1],t=n[2],i=n[3],r=n[4],o=n[5].split(",").map((e=>e.trim())).filter((e=>!!e)),s=(n,t,s)=>{const a=e?n:`clamp(${n},0.0,1.0)`;return`${i}=${r}(${o.map((e=>`mix(${e+t},${e+s},${a})`)).join(",")});`};return{type:"varying",returnType:t,name:i,getter:r,inputs:o,generate:s}}throw new Error(`Unrecognized lines pragma:"${e}"`)}function c(e){const n=new Map,t=new Map;for(const i of e)"attribute"===i.type?(n.set(i.name,i),i.vertexUsage=r.NONE,i.endpointUsage=r.NONE):"varying"===i.type&&t.set(i.name,i);let i,o,s;for(const t of e)if("property"===t.type){switch(t.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${t.property}"`);i=t;break;case"position":if(o)throw new Error(`Unexpected duplicate pragma for property "${t.property}"`);o=t;break;case"orientation":if(s)throw new Error(`Unexpected duplicate pragma for property "${t.property}"`);s=t;break;default:throw new Error(`Invalid pragma property "${t.property}"`)}for(const e of t.inputs)if(!n.has(e))throw new Error(`Missing attribute ${e} of property ${t.property}`)}for(const t of e)if(t.inputs)for(const e of t.inputs){const i=n.get(e);"property"!==t.type&&"varying"!==t.type||("position"===t.property?(i.vertexUsage|=r.EXTENDED,i.endpointUsage|=r.EXTENDED):"orientation"===t.property?i.endpointUsage|=r.PER_INSTANCE:(i.endpointUsage|=r.REGULAR,i.vertexUsage|=r.REGULAR))}return{varyings:t,attrs:n,width:i,position:o,orientation:s}}const u=[];u[5120]=1,u[5122]=2,u[5124]=4,u[5121]=1,u[5123]=2,u[5125]=4,u[5126]=4;var m=function(e,n,t){const i={};if(!n)return i;for(let[r,o]of e.attrs){const e=n[r];if(!(t?o.endpointUsage:o.vertexUsage))continue;const s={buffer:null,dimension:o.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!e)throw new Error(`Missing buffer for ${t?"endpoint":"vertex"} attribute '${r}'`);if("buffer"===e._reglType)s.buffer=e,s.type=s.buffer._buffer.dtype;else{if("buffer"!==e.buffer._reglType)throw new Error(`Invalid buffer for attribute '${r}'`);if(s.buffer=e.buffer,g(e,"dimension")&&e.dimension!==s.dimension)throw new Error(`Size of attribute(${e.dimension})does not match dimension specified in shader pragma(${o.dimension})`);g(e,"offset")&&(s.offset=e.offset),g(e,"type")?s.type=v[e.type]:s.type=s.buffer._buffer.dtype,g(e,"divisor")&&(s.divisor=e.divisor),g(e,"stride")&&(s.stride=e.stride)}s.bytesPerElement=h[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*o.dimension),i[r]=s}return i};const h=u,v={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126};function g(e,n){return Object.prototype.hasOwnProperty.call(e,n)}const y=[];y[1]="float",y[2]="vec2",y[3]="vec3",y[4]="vec4";var C=function(e,n,t){const i=t?["B","C","D"]:["A","B","C","D"],r=[],o={};return e.attrs.forEach(((e,s)=>{const a=t?e.endpointUsage:e.vertexUsage;if(!a)return;const p=[];function f(e,i){const r=s+i;if(p.push(r),t){const t=a&b.PER_INSTANCE?1:3;o[r]={buffer:n.prop(`buffers.${s}.buffer`),offset:(n,t)=>t.buffers[s].offset+t.buffers[s].stride*((t.orientation!==x.CAP_START&&t.splitCaps?3:0)+e),stride:(e,n)=>n.buffers[s].stride*t*(n.splitCaps?2:1),divisor:(e,n)=>n.buffers[s].divisor}}else o[r]={buffer:n.prop(`buffers.${s}.buffer`),offset:(n,t)=>t.buffers[s].offset+t.buffers[s].stride*e,stride:(e,n)=>n.buffers[s].stride,divisor:(e,n)=>n.buffers[s].divisor}}if(a&b.PER_INSTANCE&&f(0,""),a&b.REGULAR||a&b.EXTENDED)for(let e=0;e<i.length;e++){const n=i[e];(a&b.EXTENDED||"D"!==n&&"A"!==n)&&f(e,n)}r.push(`attribute ${w[e.dimension]} ${p.join(",")};`)})),e.varyings.forEach(((e,n)=>{r.push(`varying ${e.returnType} ${n};`)})),{glsl:r.join("\n"),attrs:o}};const b=i,w=y,x=e;const B=t,A=o,$=m,E=C,R=function(e,n,t){return function(i){if(!i)return t;if(-1===n.indexOf(i))throw new Error(`Invalid ${e} type. Valid options are:${n.join(",")}.`);return i}},D=e;var T=_;_.CAP_START=D.CAP_START,_.CAP_END=D.CAP_END;const j=new Set(["count","instances","attributes","elements"]),I=["round","bevel","miter"],N=["round","square","none"],S=[1,1],P=[2,2/Math.sqrt(3)];function _(e,n={}){const{vert:t=null,frag:i=null,debug:r=!1,insertCaps:o=!1}=n,s={...n};for(const e of["vert","frag","debug","insertCaps"])delete s[e];const a=Object.keys(s),p=0===a.length;if(a.forEach((e=>{if(j.has(e))throw new Error(`Invalid parameter '${e}'. Parameters ${[...j].map((e=>`'${e}'`)).join(",")} may not be forwarded to regl.`)})),!t)throw new Error("Missing vertex shader,`vert`");if(!i)throw new Error("Missing fragment shader,`frag`");const f=A(t),l=E(f,e,!1),d=E(f,e,!0),c=e({uniforms:{resolution:e=>[e.viewportWidth,e.viewportHeight]}}),u=p?(e,n)=>n():e(s),m={};r&&(m.debugInstanceID={buffer:e.buffer(new Uint16Array([...Array(16384).keys()])),divisor:1}),m.index={buffer:e.buffer(new Int8Array([...Array(184).keys()])),divisor:0};const h={regl:e,meta:f,segmentSpec:l,endpointSpec:d,frag:i,indexAttributes:m,debug:r,insertCaps:o},v=B(!1,!1,h),g=B(!0,!1,h),y=B(!1,!0,h),C=B(!0,!0,h),b=R("join",I,"miter"),w=R("cap",N,"square"),x=[],T=[],_=[],U=[];function k(e){u(e,(()=>{x.length&&g(x),_.length&&v(_),T.length&&C(T),U.length&&y(U),x.length=0,_.length=0,T.length=0,U.length=0}))}return function(e){if(!e)return;const n=Array.isArray(e);n||(e=[e]);const t=p&&!n;c((()=>{for(const n of e){const e=b(n.join),i=w(n.cap);let r=void 0===n.capResolution?12:n.capResolution;"square"===i?r=3:"none"===i&&(r=1);let o=1;"round"===e&&(o=void 0===n.joinResolution?8:n.joinResolution),r*=2,o*=2;const s="bevel"===e?1:void 0===n.miterLimit?4:n.miterLimit,a={joinRes2:o,capRes2:r,capScale:"square"===i?P:S,capType:i,miterLimit:s,primitive:n.primitive};if(n.endpointAttributes&&n.endpointCount){const t={buffers:$(f,n.endpointAttributes,!0),count:n.endpointCount,...a},i="round"===e?T:U;f.orientation?i.push({...t,splitCaps:!1}):i.push({...t,orientation:D.CAP_START,splitCaps:!0},{...t,orientation:D.CAP_END,splitCaps:!0})}if(n.vertexAttributes&&n.vertexCount){("round"===e?x:_).push({buffers:$(f,n.vertexAttributes,!1),count:n.vertexCount,...a})}t||k(n)}t&&k(e)}))}}return T}));