!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).reglLines=t()}(this,(function(){"use strict";var n={CAP_START:0,CAP_END:1,CAP_SHORT:2};function t(n){return n&&n.default||n}var e=t(Object.freeze({__proto__:null,CAP_START:0,CAP_END:1,CAP_SHORT:2,default:n})),i=`\n#ifndef PI\n#define PI ${Math.PI}\n#endif\n\n#define CAP_START ${e.CAP_START}.0\n#define CAP_END ${e.CAP_END}.0\n\nfloat miterExtension(vec2 t01, vec2 t12) {\n  float cosTheta = dot(t01, t12);\n  if (cosTheta - 1e-7 < -1.0) return 0.0;\n  float sinTheta = t01.x * t12.y - t01.y * t12.x;\n  return sinTheta / (1.0 + cosTheta);\n}\n\nbool isnan(float val) {\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}`,o=function({regl:n,frag:t,meta:e,segmentSpec:o,indexAttributes:r,debug:a}){return n({vert:`${e.glsl}\n\nattribute vec2 linePosition;\n${o.glsl}\n\nuniform float miterLimit;\nuniform vec2 resolution;\n\nvarying vec2 lineCoord;\nvarying float computedWidth;\n\n${a?"attribute float index;":""}\n${a?"attribute float debugInstanceID;":""}\n${a?"varying vec2 triStripGridCoord;":""}\n${a?"varying float instanceID;":""}\n\n${i}\n\nvoid main() {\n  ${a?"instanceID = debugInstanceID;":""}\n  ${a?"triStripGridCoord = vec2(floor(index / 2.0), mod(index, 2.0));":""}\n  lineCoord.x = 0.0;\n  lineCoord.y = linePosition.y;\n\n  // Project all four points\n  vec4 pA = ${e.position.generate("A")};\n  vec4 pB = ${e.position.generate("B")};\n  vec4 pC = ${e.position.generate("C")};\n  vec4 pD = ${e.position.generate("D")};\n\n  if (pA.w == 0.0 || pB.w == 0.0 || pC.w == 0.0 || pD.w == 0.0 ||\n    isnan(pA.x) || isnan(pB.x) || isnan(pC.x) || isnan(pD.x)) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  float _computedWidthB = ${e.width.generate("B")};\n  float _computedWidthC = ${e.width.generate("C")};\n  computedWidth = _computedWidthC;\n\n  bool useC = true;\n  float pBw = pB.w;\n  float computedW = pC.w;\n\n  // Convert to screen-pixel coordinates\n  pA = vec4(pA.xy * resolution, pA.zw) / pA.w;\n  pB = vec4(pB.xy * resolution, pB.zw) / pBw;\n  pC = vec4(pC.xy * resolution, pC.zw) / computedW;\n  pD = vec4(pD.xy * resolution, pD.zw) / pD.w;\n\n  // Invalidate triangles too far in front of or behind the camera plane\n  if (max(abs(pB.z), abs(pC.z)) > 1.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  // Tangent and normal vectors\n  vec2 rAB = pB.xy - pA.xy;\n  vec2 rBC = pC.xy - pB.xy;\n  vec2 rCD = pD.xy - pC.xy;\n  float lAB = length(rAB);\n  float lBC = length(rBC);\n  float lCD = length(rCD);\n\n  vec2 tAB = rAB / lAB;\n  vec2 tBC = rBC / lBC;\n  vec2 tCD = rCD / lCD;\n\n  vec2 nBC = vec2(-tBC.y, tBC.x);\n  vec2 nCD = vec2(-tCD.y, tCD.x);\n\n  gl_Position = pC;\n\n  float dirC = dot(tBC, nCD) < 0.0 ? -1.0 : 1.0;\n  if (linePosition.x > 1.0) {\n    gl_Position.xy += dirC * linePosition.y * computedWidth * nCD;\n    lineCoord.y = dirC;\n  } else {\n    bool isStart = linePosition.x < 0.5;\n\n    if (isStart) {\n      useC = false;\n      computedWidth = _computedWidthB;\n      computedW = pBw;\n    }\n\n    float m = miterExtension(isStart ? tAB : tBC, isStart ? tBC : tCD);\n    float lABC = min(lAB, lBC);\n    float lBCD = min(lBC, lCD);\n    float m0_abc = min(-m * computedWidth, lABC);\n    float m1_abc = min(m * computedWidth, lABC);\n    float m0_bcd = min(-m * computedWidth, lBCD);\n    float m1_bcd = min(m * computedWidth, lBCD);\n\n    gl_Position.xy += linePosition.y * computedWidth * nBC;\n\n    if (isStart) {\n      gl_Position.z = pB.z;\n      float dirB = dot(tAB, nBC) < 0.0 ? -1.0 : 1.0;\n      bool bIsOuter = dirB * linePosition.y > 0.0;\n      gl_Position.xy -= tBC * (lBC - (linePosition.y < 0.0 ? m0_abc : m1_abc) * (bIsOuter ? 0.0 : 1.0));\n    } else {\n      bool cIsOuter = dirC * linePosition.y > 0.0;\n      bool clipC = abs(m) > miterLimit;\n      gl_Position.xy -= tBC * (linePosition.y > 0.0 ? m1_bcd : m0_bcd) * (cIsOuter && clipC ? 0.0 : 1.0);\n    }\n  }\n\n  ${[...e.varyings.values()].map((n=>n.generate("useC","C","B"))).join("\n")}\n\n  gl_Position.xy /= resolution;\n  gl_Position *= computedW;\n}`,frag:t,attributes:{...r,...o.attrs,linePosition:{buffer:[[0,1],[0,-1],[1,1],[1,-1],[2,1]],divisor:0}},uniforms:{miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:5})};var r=function({regl:n,frag:t,meta:o,endpointSpec:r,indexPrimitive:a,indexAttributes:s,debug:l}){return n({vert:`${o.glsl}\n\nattribute float index;\n${r.glsl}\n\nuniform float miterLimit, capResolution2;\nuniform vec2 resolution, capScale;\n${o.orientation?"":"uniform float uOrientation;"}\n\nvarying vec2 lineCoord;\nvarying float computedWidth;\n\n${l?"varying vec2 triStripGridCoord;":""}\n${l?"varying float instanceID;":""}\n\n${i}\n\nvoid main() {\n  ${l?"instanceID = -1.0;":""}\n  ${l?"triStripGridCoord = vec2(floor(index / 2.0), mod(index, 2.0));":""}\n  lineCoord = vec2(0);\n\n  float orientation = ${o.orientation?o.orientation.generate(""):"mod(uOrientation,2.0)"};\n\n  // Project points\n  vec4 pB = ${o.position.generate("B")};\n  vec4 pC = ${o.position.generate("C")};\n  vec4 pD = ${o.position.generate("D")};\n\n  float widthB = ${o.width.generate("B")};\n  float widthC = ${o.width.generate("C")};\n  computedWidth = widthC;\n\n  bool useC = true;\n  float pBw = pB.w;\n  float computedW = pC.w;\n\n  // Convert to screen-pixel coordinates\n  pB = vec4(pB.xy * resolution, pB.zw) / pBw;\n  pC = vec4(pC.xy * resolution, pC.zw) / computedW;\n  pD = vec4(pD.xy * resolution, pD.zw) / pD.w;\n\n  if (pB.w == 0.0 || pC.w == 0.0 || pD.w == 0.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  // Invalidate triangles too far in front of or behind the camera plane\n  if (max(abs(pB.z), abs(pC.z)) > 1.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  // Tangent and normal vectors\n  vec2 rBC = pC.xy - pB.xy;\n  float lBC = length(rBC);\n  vec2 tBC = rBC / lBC;\n  vec2 nBC = vec2(-tBC.y, tBC.x);\n\n  vec2 rCD = pD.xy - pC.xy;\n  float lCD = length(rCD);\n  vec2 tCD = rCD / lCD;\n  vec2 nCD = vec2(-tCD.y, tCD.x);\n\n  gl_Position = pC;\n\n  // Left/right turning at each vertex\n  // Note: don't use sign for this! It's zero when the line is straight.\n  float dirC = dot(tBC, nCD) < 0.0 ? -1.0 : 1.0;\n  float endSign = orientation == CAP_START ? 1.0 : -1.0;\n\n  float i = index;\n  float iLast = capResolution2 + 4.0;\n\n  // Flip indexing if we turn the opposite direction, so that we draw backwards\n  // and get the winding order correct\n  if (dirC > 0.0) i = iLast - i;\n\n  vec2 xy = vec2(0);\n  mat2 xyBasis = mat2(0);\n\n  if (i <= capResolution2) {\n    // The first few vertices are on the cap.\n    gl_Position = pB;\n\n    computedWidth = widthB;\n    computedW = pBw;\n    useC = false;\n\n    if (mod(i, 2.0) == 0.0) {\n      xyBasis = mat2(-tBC, nBC * dirC);\n      float theta = i / capResolution2 * PI;\n      lineCoord = vec2(sin(theta), cos(theta));\n      if (abs(lineCoord.x) > 0.1) lineCoord *= capScale;\n      gl_Position.xy += computedWidth * (xyBasis * lineCoord);\n      lineCoord.y *= dirC * endSign;\n    }\n  } else {\n    i -= capResolution2 + 1.0;\n\n    vec2 position;\n    if (i == 0.0) position = vec2(0, 1);\n    if (i == 1.0) position = vec2(1, -1);\n    if (i >= 2.0) position = vec2(1, 1);\n    if (i == 3.0 && orientation == CAP_START) position = vec2(2, 1);\n\n    position.y *= dirC;\n    lineCoord.y = position.y * endSign;\n\n    if (position.x > 1.0) {\n      gl_Position.xy += position.y * computedWidth * nCD;\n    } else {\n      bool isSegmentStart = position.x < 0.5;\n\n      if (isSegmentStart) {\n        computedWidth = widthB;\n        computedW = pBw;\n        useC = false;\n        gl_Position = pB;\n      }\n\n      gl_Position.xy += position.y * computedWidth * nBC;\n\n      if (!isSegmentStart) {\n        float m = miterExtension(tBC, tCD);\n        float lBCD = min(lBC, lCD);\n        float m0 = min(-m * computedWidth, lBCD);\n        float m1 = min(m * computedWidth, lBCD);\n        bool cIsOuter = dirC * position.y > 0.0;\n        bool clipC = abs(m) > miterLimit;\n        gl_Position.xy -= tBC * (position.y > 0.0 ? m1 : m0) * (cIsOuter && (clipC || orientation == CAP_END) ? 0.0 : 1.0);\n      }\n    }\n  }\n\n  ${[...o.varyings.values()].map((n=>n.generate("useC","C","B"))).join("\n")}\n\n  gl_Position.xy /= resolution;\n  gl_Position *= computedW;\n}`,frag:t,attributes:{...s,...r.attrs},uniforms:{uOrientation:n.prop("orientation"),capScale:n.prop("capScale"),capResolution2:(n,t)=>2*t.capResolution,miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:a,instances:(n,t)=>t.splitCaps?t.orientation===e.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*t.capResolution+5})};var a=function({regl:n,meta:t,frag:e,segmentSpec:o,indexPrimitive:r,indexAttributes:a,debug:s}){return n({vert:`${t.glsl}\n\nattribute float index;\n${o.glsl}\n\nuniform float joinResolution;\nuniform vec2 resolution;\n\nvarying vec2 lineCoord;\nvarying float computedWidth;\n\n${s?"attribute float debugInstanceID;":""}\n${s?"varying vec2 triStripGridCoord;":""}\n${s?"varying float instanceID;":""}\n\n${i}\n\nvoid main() {\n  ${s?"instanceID = debugInstanceID;":""}\n  ${s?"triStripGridCoord = vec2(floor(index / 2.0), mod(index, 2.0));":""}\n  lineCoord = vec2(0);\n\n\n  // Project all four points\n  vec4 pA = ${t.position.generate("A")};\n  vec4 pB = ${t.position.generate("B")};\n  vec4 pC = ${t.position.generate("C")};\n  vec4 pD = ${t.position.generate("D")};\n\n  if (pA.w == 0.0 || pB.w == 0.0 || pC.w == 0.0 || pD.w == 0.0 ||\n    isnan(pA.x) || isnan(pB.x) || isnan(pC.x) || isnan(pD.x)) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  bool useC = true;\n  float _computedWidthB = ${t.width.generate("B")};\n  float _computedWidthC = ${t.width.generate("C")};\n  computedWidth = _computedWidthC;\n\n  float pBw = pB.w;\n  float computedW = pC.w;\n\n  // Convert to screen-pixel coordinates\n  pA = vec4(pA.xy * resolution, pA.zw) / pA.w;\n  pB = vec4(pB.xy * resolution, pB.zw) / pBw;\n  pC = vec4(pC.xy * resolution, pC.zw) / computedW;\n  pD = vec4(pD.xy * resolution, pD.zw) / pD.w;\n\n  // Invalidate triangles too far in front of or behind the camera plane\n  if (max(abs(pB.z), abs(pC.z)) > 1.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  // Tangent and normal vectors\n  vec2 rBC = pC.xy - pB.xy;\n  float lBC = length(rBC);\n  vec2 tBC = rBC / lBC;\n  vec2 nBC = vec2(-tBC.y, tBC.x);\n\n  vec2 rAB = pB.xy - pA.xy;\n  float lAB = length(rAB);\n  vec2 tAB = rAB / lAB;\n\n  vec2 rCD = vec2(pD.xy - pC.xy);\n  float lCD = length(rCD);\n  vec2 tCD = rCD / lCD;\n  vec2 nCD = vec2(-tCD.y, tCD.x);\n\n  // Left/right turning at each vertex\n  float dirB = dot(tAB, nBC) < 0.0 ? -1.0 : 1.0;\n  float dirC = dot(tBC, nCD) < 0.0 ? -1.0 : 1.0;\n\n  float i = index;\n  float iLast = joinResolution * 2.0 + 4.0;\n\n  // Flip indexing if we turn the opposite direction, so that we draw backwards\n  // and get the windind order correct\n  if (dirC > 0.0) i = iLast - i;\n\n  vec2 xy = vec2(0);\n  mat2 xyBasis = mat2(0);\n\n  gl_Position = pC;\n  gl_Position.z = i < 2.0 ? pB.z : pC.z;\n\n  if (i <= 2.0 || i == iLast) {\n    // We're in the miter/segment portion\n\n    // Use the turning direction to put the positive line coord on a consistent side\n    lineCoord.y = i == 1.0 ? dirC : -dirC;\n\n    // Extension of miter tangent to the segment\n    float mB = miterExtension(tAB, tBC) * _computedWidthB;\n    float mC = miterExtension(tBC, tCD) * _computedWidthC;\n\n    // Place the corners, with clipping against the opposite end\n    float lABC = min(lAB, lBC);\n    float lBCD = min(lBC, lCD);\n    float mB0 = dirB > 0.0 ? min(lABC, -mB) : 0.0;\n    float mC0 = dirC > 0.0 ? min(lBCD, -mC) : 0.0;\n    float mB1 = dirB > 0.0 ? 0.0 : min(lABC, mB);\n    float mC1 = dirC > 0.0 ? 0.0 : min(lBCD, mC);\n\n    xyBasis = mat2(tBC, nBC);\n    bool isStart = i < 2.0;\n    if (isStart) {\n      useC = false;\n      computedWidth = _computedWidthB;\n      computedW = pBw;\n    }\n    xy = vec2(\n      (isStart ?\n        // If start, then use the miter at B\n        (lineCoord.y > 0.0 ? mB1 : mB0) - lBC :\n\n        // Else, the miter at C\n        -(lineCoord.y > 0.0 ? mC1 : mC0)\n      ) / computedWidth,\n      lineCoord.y\n    );\n  } else {\n    gl_Position.z = pC.z;\n    vec2 xBasis = normalize(tCD + tBC);\n    vec2 yBasis = vec2(-xBasis.y, xBasis.x);\n    xyBasis = mat2(xBasis, yBasis);\n\n    if (mod(i, 2.0) != 0.0) {\n      // Odd-numbered point in this range are around the arc. (Even numbered points in this\n      // range are a no-op and fall through to just point C)\n      lineCoord.y = dirC;\n\n      // Our indexing is offset by three, and every other index is just the center point\n      // pC (which we repeat a bunch since we're drawing a triangle strip)\n      i = (i - 3.0) * 0.5;\n      if (dirC > 0.0) i = joinResolution - i;\n\n      float theta = acos(clamp(dot(nBC, nCD), -1.0, 1.0)) * (0.5 - i / joinResolution);\n      xy = dirC * vec2(sin(theta), cos(theta));\n    }\n  }\n\n  ${[...t.varyings.values()].map((n=>n.generate("useC","C","B"))).join("\n")}\n\n  // Compute the final position\n  gl_Position.xy += computedWidth * (xyBasis * xy);\n  gl_Position.xy /= resolution;\n  gl_Position *= computedW;\n}`,frag:e,attributes:{...a,...o.attrs},uniforms:{joinResolution:n.prop("joinResolution")},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:(n,t)=>2*t.joinResolution+5})};var s=function({regl:n,meta:t,frag:o,endpointSpec:r,indexAttributes:a,indexPrimitive:s,debug:l}){return n({vert:`${t.glsl}\n\nattribute float index;\n${r.glsl}\n\nuniform float joinResolution, capResolution2;\nuniform vec2 resolution, capScale;\n${t.orientation?"":"uniform float uOrientation;"}\n\nvarying vec2 lineCoord;\nvarying float computedWidth;\n\n${l?"varying vec2 triStripGridCoord;":""}\n${l?"varying float instanceID;":""}\n\n${i}\n\nvoid main() {\n  ${l?"instanceID = -1.0;":""}\n  ${l?"triStripGridCoord = vec2(floor(index / 2.0), mod(index, 2.0));":""}\n  lineCoord = vec2(0);\n\n  float orientation = ${t.orientation?t.orientation.generate(""):"mod(uOrientation,2.0)"};\n\n  // Project points\n  vec4 pB = ${t.position.generate("B")};\n  vec4 pC = ${t.position.generate("C")};\n  vec4 pD = ${t.position.generate("D")};\n\n  if (pB.w == 0.0 || pC.w == 0.0 || pD.w == 0.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  float widthB = ${t.width.generate("B")};\n  float widthC = ${t.width.generate("C")};\n  computedWidth = widthC;\n\n  bool useC = true;\n  float pBw = pB.w;\n  float computedW = pC.w;\n\n  // Convert to screen-pixel coordinates\n  pB = vec4(pB.xy * resolution, pB.zw) / pBw;\n  pC = vec4(pC.xy * resolution, pC.zw) / computedW;\n  pD = vec4(pD.xy * resolution, pD.zw) / pD.w;\n\n  // Invalidate triangles too far in front of or behind the camera plane\n  if (max(abs(pB.z), abs(pC.z)) > 1.0) {\n    gl_Position = vec4(0);\n    return;\n  }\n\n  // Tangent and normal vectors\n  vec2 rBC = pC.xy - pB.xy;\n  float lBC = length(rBC);\n  vec2 tBC = rBC / lBC;\n  vec2 nBC = vec2(-tBC.y, tBC.x);\n\n  vec2 rCD = pD.xy - pC.xy;\n  float lCD = length(rCD);\n  vec2 tCD = rCD / lCD;\n  vec2 nCD = vec2(-tCD.y, tCD.x);\n\n  // Left/right turning at each vertex\n  // Note: don't use sign for this! It's zero when the line is straight.\n  float dirC = dot(tBC, nCD) < 0.0 ? -1.0 : 1.0;\n\n  float i = index;\n  float iLast = joinResolution * 2.0 + capResolution2 + 4.0;\n\n  // Flip indexing if we turn the opposite direction, so that we draw backwards\n  // and get the winding order correct\n  if (dirC > 0.0) i = iLast - i;\n\n  vec2 xy = vec2(0);\n  mat2 xyBasis = mat2(0);\n\n  if (i < capResolution2 + 1.0) {\n    // The first few vertices are on the cap.\n    i -= capResolution2;\n    gl_Position = pB;\n    computedWidth = widthB;\n    useC = false;\n    computedW = pBw;\n\n    if (mod(i, 2.0) == 1.0) {\n      lineCoord = vec2(0);\n    } else {\n      mat2 xyBasis = mat2(tBC, nBC);\n      xyBasis = mat2(tBC, nBC);\n      float theta = i / capResolution2 * PI;\n      xy = vec2(sin(theta), -cos(theta) * dirC);\n      if (abs(xy.x) > 0.1) xy *= capScale;\n      lineCoord = xy;\n      if (orientation == CAP_END) lineCoord.y = -lineCoord.y;\n      gl_Position.xy += computedWidth * (xyBasis * xy);\n    }\n  } else {\n    i -= capResolution2;\n    iLast = joinResolution * 2.0 + 4.0;\n\n    gl_Position = pC;\n\n    bool isSegment = i <= 2.0 || i == iLast;\n    if (!isSegment && orientation == CAP_END) i = 3.0;\n    if (i <= 2.0 || i == iLast) {\n      // We're in the miter/segment portion\n\n      // Use the turning direction to put the positive line coord on a consistent side\n      lineCoord.y = i == 1.0 ? dirC : -dirC;\n\n      // Extension of miter tangent to the segment\n      float mC = miterExtension(tBC, tCD) * widthC;\n\n      // Place the corners, with clipping against the opposite end\n      float lBCD = min(lBC, lCD);\n      float mC0 = dirC > 0.0 ? min(lBCD, -mC) : 0.0;\n      float mC1 = dirC > 0.0 ? 0.0 : min(lBCD, mC);\n\n      xyBasis = mat2(tBC, nBC);\n      bool isStart = i < 2.0;\n      if (isStart) {\n        useC = false;\n        computedWidth = widthB;\n        computedW = pBw;\n      }\n      gl_Position.z = isStart ? pB.z : pC.z;\n      xy = vec2(\n        (isStart ?\n          // If so, then use the miter at B\n          -lBC :\n\n          // Else, the miter at C\n          -(lineCoord.y > 0.0 ? mC1 : mC0)\n        ) / computedWidth,\n        lineCoord.y\n      );\n    } else {\n      gl_Position.z = pC.z;\n\n      vec2 xBasis = normalize(tCD + tBC);\n      vec2 yBasis = vec2(-xBasis.y, xBasis.x);\n      xyBasis = mat2(xBasis, yBasis);\n\n      if (mod(i, 2.0) != 0.0) {\n        // Odd-numbered point in this range are around the arc. (Even numbered points in this\n        // range are a no-op and fall through to just point C)\n        lineCoord.y = dirC;\n\n        // Our indexing is offset by three, and every other index is just the center point\n        // pC (which we repeat a bunch since we're drawing a triangle strip)\n        i = (i - 3.0) * 0.5;\n        if (dirC > 0.0) i = joinResolution - i;\n\n        float theta = acos(clamp(dot(nBC, nCD), -1.0, 1.0)) * (0.5 - i / joinResolution);\n        xy = dirC * vec2(sin(theta), cos(theta));\n      }\n    }\n\n    if (orientation == CAP_END) lineCoord.y = -lineCoord.y;\n\n    // Compute the final position\n    gl_Position.xy += computedWidth * (xyBasis * xy);\n  }\n\n  ${[...t.varyings.values()].map((n=>n.generate("useC","C","B"))).join("\n")}\n\n  gl_Position.xy /= resolution;\n  gl_Position *= computedW;\n}`,frag:o,attributes:{...a,...r.attrs},uniforms:{joinResolution:n.prop("joinResolution"),capResolution2:(n,t)=>2*t.capResolution,uOrientation:n.prop("orientation"),capScale:n.prop("capScale")},primitive:"triangle strip",instances:(n,t)=>t.splitCaps?t.orientation===e.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*(t.joinResolution+t.capResolution)+5})};var l=0,p=1,c=2,d=4,f=function(n){const t=[],e=n.split("\n");for(let n=0;n<e.length;n++)e[n]=e[n].replace(u,(function(n,e){return t.push(B(e)),""}));return{glsl:e.join("\n").trim(),...h(t)}};const u=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,C=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,m=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,g=/^\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,v={float:1,vec2:2,vec3:3,vec4:4};function B(n){let t;if(t=(n=n.trim()).match(C)){return{type:"attribute",dimension:v[t[1]],name:t[2]}}if(t=n.match(m)){const n=t[1],e={width:"float",position:"vec4",orientation:"bool"}[n],i=t[2],o=t[3].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t)=>`${i}(${o.map((e=>(t||"")+e+n)).join(", ")})`;return{type:"property",property:n,returnType:e,name:i,inputs:o,generate:r}}if(t=n.match(g)){const n=t[1],e=t[2],i=t[3],o=t[4].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t,r)=>`${e} = ${i}(${o.map((e=>`(${n}) ? (${e+t}) : (${e+r})`)).join(", ")});`;return{type:"varying",returnType:n,name:e,getter:i,inputs:o,generate:r}}throw new Error(`Unrecognized lines pragma: "${n}"`)}function h(n){const t=new Map,e=new Map;for(const i of n)"attribute"===i.type?(t.set(i.name,i),i.vertexUsage=l,i.endpointUsage=l):"varying"===i.type&&e.set(i.name,i);let i,o,r;for(const e of n)if("property"===e.type){switch(e.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);i=e;break;case"position":if(o)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);o=e;break;case"orientation":if(r)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);r=e;break;default:throw new Error(`Invalid pragma property "${e.property}"`)}for(const n of e.inputs)if(!t.has(n))throw new Error(`Missing attribute ${n} of property ${e.property}`)}for(const e of n)if(e.inputs)for(const n of e.inputs){const i=t.get(n);"property"!==e.type&&"varying"!==e.type||("position"===e.property?(i.vertexUsage|=c,i.endpointUsage|=c):"orientation"===e.property?i.endpointUsage|=d:(i.endpointUsage|=p,i.vertexUsage|=p))}return{varyings:e,attrs:t,width:i,position:o,orientation:r}}const y=[];y[5120]=1,y[5122]=2,y[5124]=4,y[5121]=1,y[5123]=2,y[5125]=4,y[5126]=4;var x=y,w={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126},b=t(Object.freeze({__proto__:null,int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126,default:w})),D=function(n,t,e){const i={};if(!t)return i;for(let[o,r]of n.attrs){const n=t[o];if(!(e?r.endpointUsage:r.vertexUsage))continue;const a={buffer:null,dimension:r.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!n)throw new Error(`Missing buffer for ${e?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===n._reglType)a.buffer=n,a.type=a.buffer._buffer.dtype;else{if("buffer"!==n.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'`);if(a.buffer=n.buffer,n.hasOwnProperty("dimension")&&n.dimension!==a.dimension)throw new Error(`Size of attribute (${n.dimension}) does not match dimension specified in shader pragma (${r.dimension})`);n.hasOwnProperty("offset")&&(a.offset=n.offset),n.hasOwnProperty("type")?a.type=b[n.type]:a.type=a.buffer._buffer.dtype,n.hasOwnProperty("divisor")&&(a.divisor=n.divisor),n.hasOwnProperty("stride")&&(a.stride=n.stride)}a.bytesPerElement=x[a.type],Number.isNaN(a.stride)&&(a.stride=a.bytesPerElement*r.dimension),i[o]=a}return i};const P=[];P[1]="float",P[2]="vec2",P[3]="vec3",P[4]="vec4";var $=P,_=function(n,t,i){const o=i?["B","C","D"]:["A","B","C","D"],r=[],a={};return n.attrs.forEach(((n,s)=>{const l=i?n.endpointUsage:n.vertexUsage;if(!l)return;const f=[];function u(n,o){const r=s+o;if(f.push(r),i){const i=l&d?1:3;a[r]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,i)=>i.buffers[s].offset+i.buffers[s].stride*((i.orientation!==e.CAP_START&&i.splitCaps?3:0)+n),stride:(n,t)=>t.buffers[s].stride*i*(t.splitCaps?2:1),divisor:(n,t)=>t.buffers[s].divisor}}else a[r]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*n,stride:(n,t)=>t.buffers[s].stride,divisor:(n,t)=>t.buffers[s].divisor}}if(l&d&&u(0,""),l&p||l&c)for(let n=0;n<o.length;n++){const t=o[n];(l&c||"D"!==t&&"A"!==t)&&u(n,t)}r.push(`attribute ${$[n.dimension]} ${f.join(", ")};`)})),n.varyings.forEach(((n,t)=>{r.push(`varying ${n.returnType} ${t};`)})),{glsl:r.join("\n"),attrs:a}};var A=function(n,t,e,i){if(!n)return t;if(-1===e.indexOf(n))throw new Error(`Invalid ${i} type. Options are ${JSON.stringify(e).join(", ")}.`);return n},S=R;R.CAP_START=e.CAP_START,R.CAP_END=e.CAP_END;const W=new Set(["count","instances","attributes","elements"]);function R(n,t={}){const{vert:i=null,frag:l=null,debug:p=!1}=t,c={...t};for(const n of["vert","frag","debug"])delete c[n];const d=Object.keys(c),u=0===d.length;if(d.forEach((n=>{if(W.has(n))throw new Error(`Invalid parameter '${n}'. Parameters ${[...W].map((n=>`'${n}'`)).join(", ")} may not be forwarded to regl.`)})),!i)throw new Error("Missing vertex shader, `vert`");if(!l)throw new Error("Missing fragment shader, `frag`");const C=f(i),m=_(C,n,!1),g=_(C,n,!0),v=n({uniforms:{resolution:n=>[n.viewportWidth,n.viewportHeight]}}),B=u?(n,t)=>t():n(c);let h,y;const x={};if(p){const t=16384;x.debugInstanceID={buffer:n.buffer(new Uint16Array([...Array(t).keys()])),divisor:1}}y="triangle strip",h=n.buffer(new Int8Array([...Array(125).keys()])),x.index={buffer:h,divisor:0};const w={regl:n,meta:C,segmentSpec:m,endpointSpec:g,frag:l,indexBuffer:h,indexPrimitive:"triangle strip",indexAttributes:x,debug:p},b=o(w),P=r(w),$=a(w),S=s(w),R=["round","bevel","miter"],j=["round","square","none"],T=[1,1],z=[2/Math.sqrt(3),2];return function(n){if(!n)return;const t=Array.isArray(n);t||(n=[n]);const i=u&&!t,o=[],r=[],a=[],s=[];function l(n){B(n,(()=>{o.length&&$(o),a.length&&b(a),r.length&&S(r),s.length&&P(s),o.length=0,a.length=0,r.length=0,s.length=0}))}v((()=>{for(const t of n){const n=D(C,t.vertexAttributes,!1),p=D(C,t.endpointAttributes,!0),c=A(t.join,"miter",R,"join"),d=A(t.cap,"square",j,"cap"),f=void 0===t.joinResolution?8:t.joinResolution;let u=void 0===t.capResolution?12:t.capResolution;"square"===d?u=3:"none"===d&&(u=1);const m="bevel"===c?1:void 0===t.miterLimit?4:t.miterLimit,g="square"===d?z:T;let v,B;if(t.endpointAttributes&&(v={buffers:p,count:t.endpointCount,joinResolution:f,capResolution:u,capScale:g,miterLimit:m},C.orientation),t.vertexAttributes&&(B={buffers:n,count:t.vertexCount,joinResolution:f,capResolution:u,miterLimit:m}),B){("round"===c?o:a).push(B)}if(v){const n="round"===c?r:s;C.orientation?n.push({...v,splitCaps:!1}):n.push({...v,orientation:e.CAP_START,splitCaps:!0},{...v,orientation:e.CAP_END,splitCaps:!0})}i||l(t)}i&&l(n)}))}}return S}));