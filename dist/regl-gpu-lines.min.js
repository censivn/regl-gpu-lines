!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).reglLines=t()}(this,(function(){"use strict";var n={CAP_START:0,CAP_END:1,CAP_SHORT:2};var t=`\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n#define CAP_START ${n.CAP_START}.0\n#define CAP_END ${n.CAP_END}.0\nfloat miterExtension(vec2 t01,vec2 t12){float cosTheta=dot(t01,t12);if(cosTheta-1e-7<-1.0)return 0.0;float sinTheta=t01.x*t12.y-t01.y*t12.x;return sinTheta/(1.0+cosTheta);}bool isnan(float val){return(val<0.0||0.0<val||val==0.0)?false:true;}bool invalid(vec4 p){return p.w==0.0||isnan(p.x);}bool isSelfIntersection(vec2 tBC,vec2 tCD,float widthC,float lBCD){if(dot(tBC,tCD)>0.0)return false;return length(tBC+tCD)*lBCD<2.0*widthC;}`;const e=t;var i=function({regl:n,frag:t,meta:i,segmentSpec:o,indexAttributes:r,debug:s}){return n({vert:`${i.glsl}attribute vec2 linePosition;${o.glsl}uniform float miterLimit;uniform vec2 resolution;varying vec2 lineCoord;varying float computedWidth;${s?"attribute float index;":""}${s?"attribute float debugInstanceID;":""}${s?"varying vec2 triStripGridCoord;":""}${s?"varying float instanceID;":""}${e}void main(){${s?"instanceID=debugInstanceID;":""}${s?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}lineCoord.x=0.0;lineCoord.y=linePosition.y;vec4 pA=${i.position.generate("A")};vec4 pB=${i.position.generate("B")};vec4 pC=${i.position.generate("C")};vec4 pD=${i.position.generate("D")};if(pA.w==0.0||pB.w==0.0||pC.w==0.0||pD.w==0.0||\nisnan(pA.x)||isnan(pB.x)||isnan(pC.x)||isnan(pD.x)){gl_Position=vec4(0);return;}float _computedWidthB=${i.width.generate("B")};float _computedWidthC=${i.width.generate("C")};computedWidth=_computedWidthC;float useC=1.0;float pBw=pB.w;float computedW=pC.w;pA=vec4(pA.xy*resolution,pA.zw)/pA.w;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}vec2 rAB=pB.xy-pA.xy;vec2 rBC=pC.xy-pB.xy;vec2 rCD=pD.xy-pC.xy;float lAB=length(rAB);float lBC=length(rBC);float lCD=length(rCD);vec2 tAB=rAB/lAB;vec2 tBC=rBC/lBC;vec2 tCD=rCD/lCD;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 nCD=vec2(-tCD.y,tCD.x);gl_Position=pC;float dirC=dot(tBC,nCD)<0.0?-1.0:1.0;if(linePosition.x>1.0){gl_Position.xy+=dirC*linePosition.y*computedWidth*nCD;lineCoord.y=dirC;} else {bool isStart=linePosition.x<0.5;if(isStart){useC=0.0;computedWidth=_computedWidthB;computedW=pBw;}float m=miterExtension(isStart?tAB:tBC,isStart?tBC:tCD);float lABC=min(lAB,lBC);float lBCD=min(lBC,lCD);float m0_abc=min(-m*computedWidth,lABC);float m1_abc=min(m*computedWidth,lABC);float m0_bcd=min(-m*computedWidth,lBCD);float m1_bcd=min(m*computedWidth,lBCD);gl_Position.xy+=linePosition.y*computedWidth*nBC;if(isStart){gl_Position.z=pB.z;float dirB=dot(tAB,nBC)<0.0?-1.0:1.0;bool bIsOuter=dirB*linePosition.y>0.0;gl_Position.xy-=tBC*(lBC-(linePosition.y<0.0?m0_abc:m1_abc)*(bIsOuter?0.0:1.0));} else {bool cIsOuter=dirC*linePosition.y>0.0;bool clipC=abs(m)>miterLimit;gl_Position.xy-=tBC*(linePosition.y>0.0?m1_bcd:m0_bcd)*(cIsOuter && clipC?0.0:1.0);}}${[...i.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}gl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:t,attributes:{...r,...o.attrs,linePosition:{buffer:[[0,1],[0,-1],[1,1],[1,-1],[2,1]],divisor:0}},uniforms:{miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:5})};const o=n,r=t;var s=function({regl:n,frag:t,meta:e,endpointSpec:i,indexPrimitive:s,indexAttributes:a,debug:l}){return n({vert:`${e.glsl}attribute float index;${i.glsl}uniform float miterLimit,capResolution2;uniform vec2 resolution,capScale;${e.orientation?"":"uniform float uOrientation;"}varying vec2 lineCoord;varying float computedWidth;${l?"varying vec2 triStripGridCoord;":""}${l?"varying float instanceID;":""}${r}void main(){${l?"instanceID=-1.0;":""}${l?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}lineCoord=vec2(0);float orientation=${e.orientation?e.orientation.generate(""):"mod(uOrientation,2.0)"};vec4 pB=${e.position.generate("B")};vec4 pC=${e.position.generate("C")};vec4 pD=${e.position.generate("D")};float widthB=${e.width.generate("B")};float widthC=${e.width.generate("C")};computedWidth=widthC;float useC=1.0;float pBw=pB.w;float computedW=pC.w;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(pB.w==0.0||pC.w==0.0||pD.w==0.0){gl_Position=vec4(0);return;}if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}vec2 rBC=pC.xy-pB.xy;float lBC=length(rBC);vec2 tBC=rBC/lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 rCD=pD.xy-pC.xy;float lCD=length(rCD);vec2 tCD=rCD/lCD;vec2 nCD=vec2(-tCD.y,tCD.x);gl_Position=pC;float dirC=dot(tBC,nCD)<0.0?-1.0:1.0;float endSign=orientation==CAP_START?1.0:-1.0;float i=index;float iLast=capResolution2+4.0;if(dirC>0.0)i=iLast-i;vec2 xy=vec2(0);mat2 xyBasis=mat2(0);if(i<=capResolution2){gl_Position=pB;computedWidth=widthB;computedW=pBw;useC=0.0;if(mod(i,2.0)==0.0){xyBasis=mat2(-tBC,nBC*dirC);float theta=i/capResolution2*PI;lineCoord=vec2(sin(theta),cos(theta));if(abs(lineCoord.x)>0.1)lineCoord*=capScale;gl_Position.xy+=computedWidth*(xyBasis*lineCoord);lineCoord.y*=dirC*endSign;}} else {i-=capResolution2+1.0;vec2 position;if(i==0.0)position=vec2(0,1);if(i==1.0)position=vec2(1,-1);if(i>=2.0)position=vec2(1,1);if(i==3.0 && orientation==CAP_START)position=vec2(2,1);position.y*=dirC;lineCoord.y=position.y*endSign;if(position.x>1.0){gl_Position.xy+=position.y*computedWidth*nCD;} else {bool isSegmentStart=position.x<0.5;if(isSegmentStart){computedWidth=widthB;computedW=pBw;useC=0.0;gl_Position=pB;}gl_Position.xy+=position.y*computedWidth*nBC;if(!isSegmentStart){float m=miterExtension(tBC,tCD);float lBCD=min(lBC,lCD);float m0=min(-m*computedWidth,lBCD);float m1=min(m*computedWidth,lBCD);bool cIsOuter=dirC*position.y>0.0;bool clipC=abs(m)>miterLimit;gl_Position.xy-=tBC*(position.y>0.0?m1:m0)*(cIsOuter &&(clipC||orientation==CAP_END)?0.0:1.0);}}}${[...e.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}gl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:t,attributes:{...a,...i.attrs},uniforms:{uOrientation:n.prop("orientation"),capScale:n.prop("capScale"),capResolution2:(n,t)=>2*t.capResolution,miterLimit:(n,t)=>Math.sqrt(t.miterLimit*t.miterLimit-1)},primitive:s,instances:(n,t)=>t.splitCaps?t.orientation===o.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*t.capResolution+5})};const a=t;var l=function({regl:n,meta:t,frag:e,segmentSpec:i,indexAttributes:o,debug:r}){return n({vert:`${t.glsl}attribute float index;${i.glsl}uniform float jres2;uniform vec2 resolution;varying vec2 lineCoord;${r?"attribute float debugInstanceID;":""}${r?"varying vec2 triStripGridCoord;":""}${r?"varying float instanceID;":""}${a}void main(){gl_PointSize=10.0;${r?"instanceID=debugInstanceID;":""}${r?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}lineCoord=vec2(0);vec4 pA=${t.position.generate("A")};vec4 pB=${t.position.generate("B")};vec4 pC=${t.position.generate("C")};vec4 pD=${t.position.generate("D")};if(invalid(pA)||invalid(pB)||invalid(pC)||invalid(pD)){gl_Position=vec4(0);return;}bool isStart=index<=jres2+3.0;if(isStart){vec4 tmp;tmp=pC; pC=pB; pB=tmp;tmp=pD; pD=pA; pA=tmp;}float useC=isStart?0.0:1.0;float _computedWidthB=isStart?${t.width.generate("C")}:${t.width.generate("B")};float _computedWidthC=isStart?${t.width.generate("B")}:${t.width.generate("C")};float pBw=pB.w;float computedW=pC.w;pA=vec4(pA.xy*resolution,pA.zw)/pA.w;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}vec2 rBC=pC.xy-pB.xy;float lBC=length(rBC);vec2 tBC=rBC/lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 rAB=pB.xy-pA.xy;float lAB=length(rAB);vec2 tAB=rAB/lAB;vec2 rCD=vec2(pD.xy-pC.xy);float lCD=length(rCD);vec2 tCD=rCD/lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float lBCD=min(lBC,lCD);float dirB=dot(tAB,nBC)<0.0?-1.0:1.0;float dirC=dot(tBC,nCD)<=0.0?-1.0:1.0;vec2 iindex=vec2(index);float flip=dirB*dirC;if(flip<0.0){if(iindex.y==jres2+2.0)iindex-=2.0;} else {if(iindex.y==jres2+3.0)iindex-=3.0;}vec2 xy=vec2(0);mat2 xyBasis=mat2(0);gl_Position=pC;float dz=0.0;bool selfIntersects=isSelfIntersection(nBC,nCD,_computedWidthC,lBCD);if(iindex.y<jres2+1.0||iindex.y>=jres2+5.0){vec2 miterNormal=0.5*(tCD+tBC);float miterNormalLen=length(miterNormal);bool isDegenerate=miterNormalLen==0.0;vec2 xBasis=isDegenerate?nBC:miterNormal/miterNormalLen;vec2 yBasis=vec2(-xBasis.y,xBasis.x);if(isDegenerate && !isStart)xBasis=-xBasis;xyBasis=mat2(xBasis,yBasis);if(!isStart)iindex.x=2.0*jres2+4.0-iindex.x+1.0;if(mod(iindex.x,2.0)==0.0){lineCoord.y=isStart?-dirC:dirC;float cosTheta=clamp(dot(nBC,nCD),-1.0,1.0);float theta=-0.5*dirC*acos(cosTheta)*(iindex.x/jres2);xy=dirC*vec2(sin(theta),cos(theta));//if(!isDegenerate)\ndz=-(pB.z-pC.z)*clamp(xy.x*_computedWidthC/lBC,-0.5,0.5);}} else {float y=iindex.x==1.0?dirC:-dirC;lineCoord.y=isStart?dirC:-dirC;float mB=miterExtension(tAB,tBC)*_computedWidthB;float mC=miterExtension(tBC,tCD)*_computedWidthC;float lABC=min(lAB,lBC);float abcClip=selfIntersects?lABC:lBC;float bcdClip=selfIntersects?lBCD:lBC;float mB0=dirB>0.0?min(abcClip,-mB):0.0;float mC0=dirC>0.0?min(bcdClip,-mC):0.0;float mB1=dirB>0.0?0.0:min(abcClip,mB);float mC1=dirC>0.0?0.0:min(bcdClip,mC);xyBasis=mat2(tBC,nBC);bool isStart=iindex.x<2.0;xy=vec2(\n(isStart?\n(y>0.0?mB1:mB0)-lBC:\n-(y>0.0?mC1:mC0)\n),\ny);if(lBC>0.0)useC=clamp(useC-dirC*xy.x/lBC*lineCoord.y,0.0,1.0);xy.x/=_computedWidthC;}${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}if(selfIntersects)gl_Position.z=mix(pB.z,pC.z,isStart?1.0-useC:useC);gl_Position.z+=dz;gl_Position.xy+=_computedWidthC*(xyBasis*xy);gl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:e,attributes:{index:{buffer:[...Array(400).keys()],divisor:0},...o,...i.attrs},uniforms:{jres2:(n,t)=>2*t.joinResolution},primitive:"triangle strip",instances:(n,t)=>t.count-3,count:(n,t)=>4*t.joinResolution+6})};const p=n,c=t;var d=function({regl:n,meta:t,frag:e,endpointSpec:i,indexAttributes:o,debug:r}){return n({vert:`${t.glsl}attribute float index;${i.glsl}uniform float joinResolution,capResolution2;uniform vec2 resolution,capScale;${t.orientation?"":"uniform float uOrientation;"}varying vec2 lineCoord;varying float computedWidth;${r?"varying vec2 triStripGridCoord;":""}${r?"varying float instanceID;":""}${c}void main(){${r?"instanceID=-1.0;":""}${r?"triStripGridCoord=vec2(floor(index/2.0),mod(index,2.0));":""}lineCoord=vec2(0);float orientation=${t.orientation?t.orientation.generate(""):"mod(uOrientation,2.0)"};vec4 pB=${t.position.generate("B")};vec4 pC=${t.position.generate("C")};vec4 pD=${t.position.generate("D")};if(pB.w==0.0||pC.w==0.0||pD.w==0.0){gl_Position=vec4(0);return;}float widthB=${t.width.generate("B")};float widthC=${t.width.generate("C")};computedWidth=widthC;float pBw=pB.w;float computedW=pC.w;float useC=1.0;pB=vec4(pB.xy*resolution,pB.zw)/pBw;pC=vec4(pC.xy*resolution,pC.zw)/computedW;pD=vec4(pD.xy*resolution,pD.zw)/pD.w;if(max(abs(pB.z),abs(pC.z))>1.0){gl_Position=vec4(0);return;}vec2 rBC=pC.xy-pB.xy;float lBC=length(rBC);vec2 tBC=rBC/lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 rCD=pD.xy-pC.xy;float lCD=length(rCD);vec2 tCD=rCD/lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float lBCD=min(lBC,lCD);float dirC=dot(tBC,nCD)<0.0?-1.0:1.0;float i=index;float iLast=joinResolution*2.0+capResolution2+4.0;vec2 xy=vec2(0);mat2 xyBasis=mat2(0);float dz=0.0;bool selfIntersects=isSelfIntersection(tBC,tCD,computedWidth,lBCD);if(i<capResolution2+1.0){i-=capResolution2;gl_Position=pB;computedWidth=widthB;useC=0.0;computedW=pBw;if(mod(i,2.0)==1.0){lineCoord=vec2(0);} else {mat2 xyBasis=mat2(tBC,nBC);xyBasis=mat2(tBC,nBC);float theta=i/capResolution2*PI;xy=vec2(sin(theta),-cos(theta)*dirC);if(abs(xy.x)>0.1)xy*=capScale;lineCoord=xy;gl_Position.xy+=computedWidth*(xyBasis*xy);}} else {i-=capResolution2;iLast=joinResolution*2.0+4.0;gl_Position=pC;bool isSegment=i<=2.0||i==iLast;if(i<=2.0||i==iLast){lineCoord.y=i==1.0?dirC:-dirC;float mC=miterExtension(tBC,tCD)*widthC;float bcdClip=selfIntersects?lBCD:lBC;float mC0=dirC>0.0?min(bcdClip,-mC):0.0;float mC1=dirC>0.0?0.0:min(bcdClip,mC);xyBasis=mat2(tBC,nBC);bool isStart=i<2.0;if(isStart)useC=0.0;gl_Position.z=isStart?pB.z:pC.z;xy=vec2(\n(isStart?\n-lBC:\n-(lineCoord.y>0.0?mC1:mC0)\n),\nlineCoord.y\n);if(!isStart)useC-=dirC*xy.x/lBC*lineCoord.y;xy.x/=computedWidth;} else {vec2 miterNormal=0.5*(tCD+tBC);float miterNormalLen=length(miterNormal);bool isDegenerate=miterNormalLen==0.0;vec2 xBasis=isDegenerate?nCD:miterNormal/miterNormalLen;vec2 yBasis=vec2(-xBasis.y,xBasis.x);xyBasis=mat2(xBasis,yBasis);if(mod(i,2.0)!=0.0){lineCoord.y=dirC;i=(i-3.0)*0.5;if(dirC>0.0)i=joinResolution-i;float cosTheta=clamp(dot(nBC,nCD),-1.0,1.0);float theta=0.5*acos(cosTheta)*(0.5-0.5*dirC-i/joinResolution);xy=dirC*vec2(sin(theta),cos(theta));if(!isDegenerate)dz=-(pB.z-pC.z)*clamp(xy.x*computedWidth/lBC,-0.5,0.5);}}gl_Position.xy+=computedWidth*(xyBasis*xy);}if(orientation==CAP_END)lineCoord=-lineCoord;${[...t.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}if(selfIntersects)gl_Position.z=mix(pB.z,pC.z,useC);gl_Position.z+=dz;gl_Position.xy/=resolution;gl_Position*=computedW;}`,frag:e,attributes:{...o,...i.attrs},uniforms:{joinResolution:n.prop("joinResolution"),capResolution2:(n,t)=>2*t.capResolution,uOrientation:n.prop("orientation"),capScale:n.prop("capScale")},primitive:"triangle strip",instances:(n,t)=>t.splitCaps?t.orientation===p.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count,count:(n,t)=>2*(t.joinResolution+t.capResolution)+4})};var C={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const f=C;var u=function(n){const t=[],e=n.split("\n");for(let n=0;n<e.length;n++)e[n]=e[n].replace(m,(function(n,e){return t.push(x(e)),""}));return{glsl:e.join("\n").trim(),...h(t)}};const m=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,B=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,v=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,y=/^\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,g={float:1,vec2:2,vec3:3,vec4:4};function x(n){let t;if(t=(n=n.trim()).match(B)){return{type:"attribute",dimension:g[t[1]],name:t[2]}}if(t=n.match(v)){const n=t[1],e={width:"float",position:"vec4",orientation:"bool"}[n],i=t[2],o=t[3].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t)=>`${i}(${o.map((e=>(t||"")+e+n)).join(",")})`;return{type:"property",property:n,returnType:e,name:i,inputs:o,generate:r}}if(t=n.match(y)){const n=t[1],e=t[2],i=t[3],o=t[4].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,t,r)=>`${e}=${i}(${o.map((e=>`mix(${e+t},${e+r},${n})`)).join(",")});`;return{type:"varying",returnType:n,name:e,getter:i,inputs:o,generate:r}}throw new Error(`Unrecognized lines pragma:"${n}"`)}function h(n){const t=new Map,e=new Map;for(const i of n)"attribute"===i.type?(t.set(i.name,i),i.vertexUsage=f.NONE,i.endpointUsage=f.NONE):"varying"===i.type&&e.set(i.name,i);let i,o,r;for(const e of n)if("property"===e.type){switch(e.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);i=e;break;case"position":if(o)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);o=e;break;case"orientation":if(r)throw new Error(`Unexpected duplicate pragma for property "${e.property}"`);r=e;break;default:throw new Error(`Invalid pragma property "${e.property}"`)}for(const n of e.inputs)if(!t.has(n))throw new Error(`Missing attribute ${n} of property ${e.property}`)}for(const e of n)if(e.inputs)for(const n of e.inputs){const i=t.get(n);"property"!==e.type&&"varying"!==e.type||("position"===e.property?(i.vertexUsage|=f.EXTENDED,i.endpointUsage|=f.EXTENDED):"orientation"===e.property?i.endpointUsage|=f.PER_INSTANCE:(i.endpointUsage|=f.REGULAR,i.vertexUsage|=f.REGULAR))}return{varyings:e,attrs:t,width:i,position:o,orientation:r}}const D=[];D[5120]=1,D[5122]=2,D[5124]=4,D[5121]=1,D[5123]=2,D[5125]=4,D[5126]=4;var b=function(n,t,e){const i={};if(!t)return i;for(let[o,r]of n.attrs){const n=t[o];if(!(e?r.endpointUsage:r.vertexUsage))continue;const s={buffer:null,dimension:r.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!n)throw new Error(`Missing buffer for ${e?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===n._reglType)s.buffer=n,s.type=s.buffer._buffer.dtype;else{if("buffer"!==n.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'`);if(s.buffer=n.buffer,A(n,"dimension")&&n.dimension!==s.dimension)throw new Error(`Size of attribute(${n.dimension})does not match dimension specified in shader pragma(${r.dimension})`);A(n,"offset")&&(s.offset=n.offset),A(n,"type")?s.type=$[n.type]:s.type=s.buffer._buffer.dtype,A(n,"divisor")&&(s.divisor=n.divisor),A(n,"stride")&&(s.stride=n.stride)}s.bytesPerElement=w[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*r.dimension),i[o]=s}return i};const w=D,$={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126};function A(n,t){return Object.prototype.hasOwnProperty.call(n,t)}const _=[];_[1]="float",_[2]="vec2",_[3]="vec3",_[4]="vec4";var P=function(n,t,e){const i=e?["B","C","D"]:["A","B","C","D"],o=[],r={};return n.attrs.forEach(((n,s)=>{const a=e?n.endpointUsage:n.vertexUsage;if(!a)return;const l=[];function p(n,i){const o=s+i;if(l.push(o),e){const e=a&S.PER_INSTANCE?1:3;r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*((e.orientation!==R.CAP_START&&e.splitCaps?3:0)+n),stride:(n,t)=>t.buffers[s].stride*e*(t.splitCaps?2:1),divisor:(n,t)=>t.buffers[s].divisor}}else r[o]={buffer:t.prop(`buffers.${s}.buffer`),offset:(t,e)=>e.buffers[s].offset+e.buffers[s].stride*n,stride:(n,t)=>t.buffers[s].stride,divisor:(n,t)=>t.buffers[s].divisor}}if(a&S.PER_INSTANCE&&p(0,""),a&S.REGULAR||a&S.EXTENDED)for(let n=0;n<i.length;n++){const t=i[n];(a&S.EXTENDED||"D"!==t&&"A"!==t)&&p(n,t)}o.push(`attribute ${E[n.dimension]} ${l.join(",")};`)})),n.varyings.forEach(((n,t)=>{o.push(`varying ${n.returnType} ${t};`)})),{glsl:o.join("\n"),attrs:r}};const S=C,E=_,R=n;const W=i,N=s,z=l,T=d,I=u,j=b,L=P,O=function(n,t,e,i){if(!n)return t;if(-1===e.indexOf(n))throw new Error(`Invalid ${i} type. Options are ${JSON.stringify(e).join(",")}.`);return n},U=n;var M=k;k.CAP_START=U.CAP_START,k.CAP_END=U.CAP_END;const G=new Set(["count","instances","attributes","elements"]);function k(n,t={}){const{vert:e=null,frag:i=null,debug:o=!1}=t,r={...t};for(const n of["vert","frag","debug"])delete r[n];const s=Object.keys(r),a=0===s.length;if(s.forEach((n=>{if(G.has(n))throw new Error(`Invalid parameter '${n}'. Parameters ${[...G].map((n=>`'${n}'`)).join(",")} may not be forwarded to regl.`)})),!e)throw new Error("Missing vertex shader,`vert`");if(!i)throw new Error("Missing fragment shader,`frag`");const l=I(e),p=L(l,n,!1),c=L(l,n,!0),d=n({uniforms:{resolution:n=>[n.viewportWidth,n.viewportHeight]}}),C=a?(n,t)=>t():n(r);let f,u;const m={};if(o){const t=16384;m.debugInstanceID={buffer:n.buffer(new Uint16Array([...Array(t).keys()])),divisor:1}}u="triangle strip",f=n.buffer(new Int8Array([...Array(124).keys()])),m.index={buffer:f,divisor:0};const B={regl:n,meta:l,segmentSpec:p,endpointSpec:c,frag:i,indexBuffer:f,indexPrimitive:"triangle strip",indexAttributes:m,debug:o},v=W(B),y=N(B),g=z(B),x=T(B),h=["round","bevel","miter"],D=["round","square","none"],b=[1,1],w=[2/Math.sqrt(3),2];return function(n){if(!n)return;const t=Array.isArray(n);t||(n=[n]);const e=a&&!t,i=[],o=[],r=[],s=[];function p(n){C(n,(()=>{i.length&&g(i),r.length&&v(r),o.length&&x(o),s.length&&y(s),i.length=0,r.length=0,o.length=0,s.length=0}))}d((()=>{for(const t of n){const n=j(l,t.vertexAttributes,!1),a=j(l,t.endpointAttributes,!0),c=O(t.join,"miter",h,"join"),d=O(t.cap,"square",D,"cap"),C=void 0===t.joinResolution?8:t.joinResolution;let f=void 0===t.capResolution?12:2*t.capResolution;"square"===d?f=3:"none"===d&&(f=1);const u="bevel"===c?1:void 0===t.miterLimit?4:t.miterLimit,m="square"===d?w:b;let B,v;if(t.endpointAttributes&&(B={buffers:a,count:t.endpointCount,joinResolution:C,capResolution:f,capScale:m,miterLimit:u}),t.vertexAttributes&&(v={buffers:n,count:t.vertexCount,joinResolution:C,capResolution:f,miterLimit:u}),v){("round"===c?i:r).push(v)}if(B){const n="round"===c?o:s;l.orientation?n.push({...B,splitCaps:!1}):n.push({...B,orientation:U.CAP_START,splitCaps:!0},{...B,orientation:U.CAP_END,splitCaps:!0})}e||p(t)}e&&p(n)}))}}return M}));