!function(n,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(n="undefined"!=typeof globalThis?globalThis:n||self).reglLines=e()}(this,(function(){"use strict";var n={CAP_START:0,CAP_END:1,CAP_SHORT:2};const e=n;var t=function(n,t,{regl:i,meta:o,frag:r,segmentSpec:s,endpointSpec:a,indexAttributes:l,insertCaps:f,debug:p}){const d=t?a:s,c=["B","C","D"];t||c.unshift("A");function u(n){return f?t?[n.capResolution,Math.max(n.capResolution,n.joinResolution)]:[Math.max(n.capResolution,n.joinResolution),Math.max(n.capResolution,n.joinResolution)]:t?[n.capResolution,n.joinResolution]:[n.joinResolution,n.joinResolution]}return i({vert:`${o.glsl}const float CAP_START=${e.CAP_START}.0;const float CAP_END=${e.CAP_END}.0;${d.glsl}attribute float index;${p?"attribute float debugInstanceID;":""}uniform vec2 vertexCount,capJoinRes;uniform vec2 resolution,capScale;uniform float miterLimit;${o.orientation||!t?"":"uniform float orientation;"}varying vec3 lineCoord;varying float dir;${p?"varying vec2 triStripCoord;":""}${p?"varying float instanceID;":""}bool invalid(vec4 p){return p.w==0.0;}const bool isRound=${n?"true":"false"};const float pi=3.141592653589793;void main(){lineCoord=vec3(0);${p?`instanceID=${t?"-1.0":"debugInstanceID"};`:""}${p?"triStripCoord=vec2(floor(index/2.0),mod(index,2.0));":""}${c.map((n=>`vec4 p${n}=${o.position.generate(n)};`)).join("\n")}bool aInvalid=${t?"false":"invalid(pA)"};bool bInvalid=invalid(pB);bool cInvalid=invalid(pC);bool dInvalid=invalid(pD);float mirrorIndex=2.0*vertexCount.x+3.0;float totalVertexCount=mirrorIndex+2.0+2.0*vertexCount.y;bool isMirrored=index>mirrorIndex;${t?"if(dInvalid && isMirrored){gl_Position=pB;return;}":""}float pw=isMirrored?pC.w:pB.w;${c.map((n=>`p${n}=vec4(vec3(p${n}.xy*resolution,p${n}.z)/p${n}.w,1);`)).join("\n")}${t?"vec4 pA=pC;":""}if(bInvalid||cInvalid||max(abs(pB.z),abs(pC.z))>1.0){gl_Position=pB;return;}float mirrorSign=isMirrored?-1.0:1.0;if(isMirrored){vec4 vTmp=pC; pC=pB; pB=vTmp;vTmp=pD; pD=pA; pA=vTmp;bool bTmp=dInvalid; dInvalid=aInvalid; aInvalid=bTmp;}${t?"bool isCap=!isMirrored;":"bool isCap=false;"};if(aInvalid){ ${f?"pA=pC; isCap=true;":"pA=2.0*pB-pC;"} }if(dInvalid){ ${f?"pD=pB;":"pD=2.0*pC-pB;"} }float width=isMirrored?${o.width.generate("C")}:${o.width.generate("B")};vec2 tBC=pC.xy-pB.xy;float lBC=length(tBC);tBC/=lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 tAB=pB.xy-pA.xy;float lAB=length(tAB);if(lAB>0.0)tAB/=lAB;vec2 nAB=vec2(-tAB.y,tAB.x);vec2 tCD=pD.xy-pC.xy;float lCD=length(tCD);if(lCD>0.0)tCD/=lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float cosB=clamp(dot(tAB,tBC),-1.0,1.0);const float tol=1e-4;float dirB=-dot(tBC,nAB);float dirC=dot(tBC,nCD);bool bCollinear=abs(dirB)<tol;bool cCollinear=abs(dirC)<tol;bool bIsHairpin=bCollinear && cosB<0.0;bool cIsHairpin=cCollinear && dot(tBC,tCD)<0.0;dirB=bCollinear?-mirrorSign:sign(dirB);dirC=cCollinear?-mirrorSign:sign(dirC);vec2 miter=bIsHairpin?-tBC:0.5*(nAB+nBC)*dirB;float i=index<=mirrorIndex?index:totalVertexCount-index;float iSeg=i-2.0*(isMirrored?vertexCount.y:vertexCount.x);if(iSeg>1.0 && iSeg<=3.0){iSeg-=2.0;if(dirB*dirC>=0.0)iSeg+=iSeg==0.0?1.0:-1.0;}vec2 xBasis=tBC;vec2 yBasis=nBC*dirB;vec2 xy=vec2(0,1);lineCoord.y=dirB*mirrorSign;if(iSeg<0.0){float m2=dot(miter,miter);float lm=length(miter);float tBCm=dot(tBC,miter);yBasis=miter/lm;bool isBevel=1.0>miterLimit*m2;if(mod(i,2.0)==0.0){if(isRound||isCap){xBasis=dirB*vec2(yBasis.y,-yBasis.x);float cnt=(isCap?capJoinRes.x:capJoinRes.y)*2.0;float theta=-0.5*(acos(cosB)*(min(i,cnt)/cnt)-pi)*(isCap?2.0:1.0);xy=vec2(cos(theta),sin(theta));if(isCap){if(xy.y>0.001)xy*=capScale;lineCoord.xy=xy.yx*lineCoord.y;}} else {yBasis=bIsHairpin?vec2(0):miter;if(!isBevel)xy.y/=m2;}} else {lineCoord.y=0.0;xy=vec2(0);if(!isRound && isBevel && !isCap){xy.y=-1.0+sqrt((1.0+cosB)*0.5);}}} else if(iSeg>0.0){lineCoord.y=-lineCoord.y;float miterExt=0.0;if(cosB>-0.9999){float sinB=tAB.x*tBC.y-tAB.y*tBC.x;miterExt=sinB/(1.0+cosB);}float m=abs(miterExt);m=min(m,min(lBC,lAB)/width);xy=vec2(m,-1);}${t?`float orientation=${o.orientation?o.orientation.generate(""):"mod(orientation,2.0)"};`:""};${t?"if(orientation==CAP_END)lineCoord.xy=-lineCoord.xy;":""}vec2 dP=mat2(xBasis,yBasis)*xy;float dC=dot(dP,tBC)*mirrorSign;float useC=(isMirrored?1.0:0.0)+dC*(width/lBC);lineCoord.z=useC<0.0||useC>1.0?1.0:0.0;${[...o.varyings.values()].map((n=>n.generate("useC","B","C"))).join("\n")}gl_Position=pB;gl_Position.xy+=width*dP;gl_Position.xy/=resolution;gl_Position*=pw;}`,frag:r,attributes:{...l,...d.attrs},uniforms:{vertexCount:(n,e)=>u(e),capJoinRes:(n,e)=>[e.capResolution,e.joinResolution],miterLimit:(n,e)=>e.miterLimit*e.miterLimit,orientation:i.prop("orientation"),capScale:i.prop("capScale")},primitive:"triangle strip",instances:t?(n,t)=>t.splitCaps?t.orientation===e.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count:(n,e)=>e.count-3,count:(n,e)=>{const t=u(e);return 6+2*(t[0]+t[1])}})};var i={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const o=i;var r=function(n){const e=[],t=n.split("\n");for(let n=0;n<t.length;n++)t[n]=t[n].replace(s,(function(n,t){return e.push(d(t)),""}));return{glsl:t.join("\n").trim(),...c(e)}};const s=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,a=/^\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,l=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,f=/^\s*(?:(extrapolate)?)\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,p={float:1,vec2:2,vec3:3,vec4:4};function d(n){let e;if(e=(n=n.trim()).match(a)){return{type:"attribute",dimension:p[e[1]],name:e[2]}}if(e=n.match(l)){const n=e[1],t={width:"float",position:"vec4",orientation:"bool"}[n],i=e[2],o=e[3].split(",").map((n=>n.trim())).filter((n=>!!n)),r=(n,e)=>`${i}(${o.map((t=>(e||"")+t+n)).join(",")})`;return{type:"property",property:n,returnType:t,name:i,inputs:o,generate:r}}if(e=n.match(f)){const n="extrapolate"===e[1],t=e[2],i=e[3],o=e[4],r=e[5].split(",").map((n=>n.trim())).filter((n=>!!n)),s=(e,t,s)=>{const a=n?e:`clamp(${e},0.0,1.0)`;return`${i}=${o}(${r.map((n=>`mix(${n+t},${n+s},${a})`)).join(",")});`};return{type:"varying",returnType:t,name:i,getter:o,inputs:r,generate:s}}throw new Error(`Unrecognized lines pragma:"${n}"`)}function c(n){const e=new Map,t=new Map;for(const i of n)"attribute"===i.type?(e.set(i.name,i),i.vertexUsage=o.NONE,i.endpointUsage=o.NONE):"varying"===i.type&&t.set(i.name,i);let i,r,s;for(const t of n)if("property"===t.type){switch(t.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${t.property}"`);i=t;break;case"position":if(r)throw new Error(`Unexpected duplicate pragma for property "${t.property}"`);r=t;break;case"orientation":if(s)throw new Error(`Unexpected duplicate pragma for property "${t.property}"`);s=t;break;default:throw new Error(`Invalid pragma property "${t.property}"`)}for(const n of t.inputs)if(!e.has(n))throw new Error(`Missing attribute ${n} of property ${t.property}`)}for(const t of n)if(t.inputs)for(const n of t.inputs){const i=e.get(n);"property"!==t.type&&"varying"!==t.type||("position"===t.property?(i.vertexUsage|=o.EXTENDED,i.endpointUsage|=o.EXTENDED):"orientation"===t.property?i.endpointUsage|=o.PER_INSTANCE:(i.endpointUsage|=o.REGULAR,i.vertexUsage|=o.REGULAR))}return{varyings:t,attrs:e,width:i,position:r,orientation:s}}const u=[];u[5120]=1,u[5122]=2,u[5124]=4,u[5121]=1,u[5123]=2,u[5125]=4,u[5126]=4;var v=function(n,e,t){const i={};if(!e)return i;for(let[o,r]of n.attrs){const n=e[o];if(!(t?r.endpointUsage:r.vertexUsage))continue;const s={buffer:null,dimension:r.dimension,offset:0,type:NaN,stride:NaN,divisor:1,bytesPerElement:NaN};if(!n)throw new Error(`Missing buffer for ${t?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===n._reglType)s.buffer=n,s.type=s.buffer._buffer.dtype;else{if("buffer"!==n.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'`);if(s.buffer=n.buffer,g(n,"dimension")&&n.dimension!==s.dimension)throw new Error(`Size of attribute(${n.dimension})does not match dimension specified in shader pragma(${r.dimension})`);g(n,"offset")&&(s.offset=n.offset),g(n,"type")?s.type=C[n.type]:s.type=s.buffer._buffer.dtype,g(n,"divisor")&&(s.divisor=n.divisor),g(n,"stride")&&(s.stride=n.stride)}s.bytesPerElement=m[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*r.dimension),i[o]=s}return i};const m=u,C={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126};function g(n,e){return Object.prototype.hasOwnProperty.call(n,e)}const y=[];y[1]="float",y[2]="vec2",y[3]="vec3",y[4]="vec4";var h=function(n,e,t){const i=t?["B","C","D"]:["A","B","C","D"],o=[],r={};return n.attrs.forEach(((n,s)=>{const a=t?n.endpointUsage:n.vertexUsage;if(!a)return;const l=[];function f(n,i){const o=s+i;if(l.push(o),t){const t=a&b.PER_INSTANCE?1:3;r[o]={buffer:e.prop(`buffers.${s}.buffer`),offset:(e,t)=>t.buffers[s].offset+t.buffers[s].stride*((t.orientation!==B.CAP_START&&t.splitCaps?3:0)+n),stride:(n,e)=>e.buffers[s].stride*t*(e.splitCaps?2:1),divisor:(n,e)=>e.buffers[s].divisor}}else r[o]={buffer:e.prop(`buffers.${s}.buffer`),offset:(e,t)=>t.buffers[s].offset+t.buffers[s].stride*n,stride:(n,e)=>e.buffers[s].stride,divisor:(n,e)=>e.buffers[s].divisor}}if(a&b.PER_INSTANCE&&f(0,""),a&b.REGULAR||a&b.EXTENDED)for(let n=0;n<i.length;n++){const e=i[n];(a&b.EXTENDED||"D"!==e&&"A"!==e)&&f(n,e)}o.push(`attribute ${x[n.dimension]} ${l.join(",")};`)})),n.varyings.forEach(((n,e)=>{o.push(`varying ${n.returnType} ${e};`)})),{glsl:o.join("\n"),attrs:r}};const b=i,x=y,B=n;const w=t,A=r,$=v,E=h,R=function(n,e,t){return function(i){if(!i)return t;if(-1===e.indexOf(i))throw new Error(`Invalid ${n} type. Valid options are:${e.join(",")}.`);return i}},D=n;var T=_;_.CAP_START=D.CAP_START,_.CAP_END=D.CAP_END;const S=new Set(["count","instances","attributes","elements"]),I=["round","bevel","miter"],j=["round","square","none"],N=[1,1],P=[2,2/Math.sqrt(3)];function _(n,e={}){const{vert:t=null,frag:i=null,debug:o=!1,insertCaps:r=!1}=e,s={...e};for(const n of["vert","frag","debug","insertCaps"])delete s[n];const a=Object.keys(s),l=0===a.length;if(a.forEach((n=>{if(S.has(n))throw new Error(`Invalid parameter '${n}'. Parameters ${[...S].map((n=>`'${n}'`)).join(",")} may not be forwarded to regl.`)})),!t)throw new Error("Missing vertex shader,`vert`");if(!i)throw new Error("Missing fragment shader,`frag`");const f=A(t),p=E(f,n,!1),d=E(f,n,!0),c=n({uniforms:{resolution:n=>[n.viewportWidth,n.viewportHeight]}}),u=l?(n,e)=>e():n(s),v={};o&&(v.debugInstanceID={buffer:n.buffer(new Uint16Array([...Array(16384).keys()])),divisor:1}),v.index={buffer:n.buffer(new Int8Array([...Array(184).keys()])),divisor:0};const m={regl:n,meta:f,segmentSpec:p,endpointSpec:d,frag:i,indexAttributes:v,debug:o,insertCaps:r},C=w(!1,!1,m),g=w(!0,!1,m),y=w(!1,!0,m),h=w(!0,!0,m),b=R("join",I,"miter"),x=R("cap",j,"square"),B=[],T=[],_=[],M=[];function U(n){u(n,(()=>{B.length&&g(B),_.length&&C(_),T.length&&h(T),M.length&&y(M),B.length=0,_.length=0,T.length=0,M.length=0}))}return function(n){if(!n)return;const e=Array.isArray(n);e||(n=[n]);const t=l&&!e;c((()=>{for(const e of n){const n=b(e.join),i=x(e.cap);let o=void 0===e.capResolution?12:e.capResolution;"square"===i?o=3:"none"===i&&(o=1);let r=1;"round"===n&&(r=void 0===e.joinResolution?8:e.joinResolution);const s="bevel"===n?1:void 0===e.miterLimit?4:e.miterLimit,a={joinResolution:r,capResolution:o,capScale:"square"===i?P:N,capType:i,miterLimit:s};if(e.endpointAttributes&&e.endpointCount){const t={buffers:$(f,e.endpointAttributes,!0),count:e.endpointCount,...a},i="round"===n?T:M;f.orientation?i.push({...t,splitCaps:!1}):i.push({...t,orientation:D.CAP_START,splitCaps:!0},{...t,orientation:D.CAP_END,splitCaps:!0})}if(e.vertexAttributes&&e.vertexCount){("round"===n?B:_).push({buffers:$(f,e.vertexAttributes,!1),count:e.vertexCount,...a})}t||U(e)}t&&U(n)}))}}return T}));