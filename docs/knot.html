<!DOCTYPE html>
<html>
<head>
  <title>regl-gpu-lines Example</title>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/javascript.min.js"></script>
</head>
<body>
<script src="https://unpkg.com/controls-state@2.0.0/dist/controls-state.min.js"></script>
<script src="https://unpkg.com/controls-gui@2.0.0/dist/controls-gui.min.js"></script>
<script src="https://unpkg.com/regl@2.1.0/dist/regl.js"></script>
<script src="https://unpkg.com/regl-gpu-lines@latest"></script>

<script>
const regl = createREGL({ extensions: ['ANGLE_instanced_arrays'] });

// Instantiate a command for drawing lines
const drawLines = reglLines(regl, {
  vert: `
    precision highp float;

    uniform float width, time, phase;
    uniform vec2 aspect;

    #pragma lines: attribute float x;
    #pragma lines: position = torusKnow(x);
    vec4 torusKnow(float x) {
      float theta = ${Math.PI} * x * 2.0;
      const float p = 3.0;
      const float q = 5.0;
      float r = cos(q * theta) + 2.0;
      float phi = p * (theta - phase);
      return vec4(
        vec3(
          aspect * r * vec2(cos(phi), sin(phi)),
          -sin(q * theta)
        ) * 0.25,
        1
      );
    }

    // Return the line width from a uniorm
    #pragma lines: width = getWidth();
    float getWidth() { return width; }`,
  frag: `
    precision highp float;
    uniform float width, borderWidth;
    uniform vec3 color;
    varying vec2 lineCoord;
    void main () {
      // Convert the line coord into an SDF
      float sdf = length(lineCoord) * width;

      // Apply a border with 1px transition
      gl_FragColor = vec4(
        mix(color, vec3(1), smoothstep(width - borderWidth - 0.5, width - borderWidth + 0.5, sdf)),
        1);
    }`,

  // Multiply the width by the pixel ratio for consistent width
  uniforms: {
    aspect: ctx => ctx.viewportWidth > ctx.viewportHeight
      ? [ctx.viewportHeight / ctx.viewportWidth, 1]
      : [1, ctx.viewportWidth / ctx.viewportHeight],
    width: (ctx, props) => ctx.pixelRatio * props.width,
    borderWidth: (ctx, props) => ctx.pixelRatio * props.borderWidth,
    time: regl.context('time'),
    phase: regl.prop('phase'),
    color: regl.prop('color')
  },

  depth: {enable: true}
});

const n = 501;

// Set up the data to be drawn. Note that we preallocate buffers and don't create
// them on every draw call.
const lineData = {
  width: Math.min(window.innerWidth, window.innerHeight) / 20,
  join: 'bevel',
  cap: 'round',
  vertexCount: n + 3,
  vertexAttributes: {
    x: regl.buffer([...Array(n + 3).keys()].map(i => i / n))
  },
  borderWidth: 5
};

function draw() {
  regl.clear({color: [0.2, 0.2, 0.2, 1]});
  drawLines([
    {...lineData, phase: 0, color: [1, 0, 0.5]},
    {...lineData, phase: Math.PI, color: [0, 0.5, 1]},
  ]);
}

draw();
window.addEventListener('resize', draw);

</script>
<style>
#code-container {
  font-family: sans-serif;
  position: absolute;
  left: 0;
  z-index: 10;
  max-height: 90%;
  overflow: auto;
  background-color: white;
}
#code-container summary {
  padding: 15px;
  cursor: pointer;
}
</style>
<div id="code-container">
<details>
<summary>Code</summary>
<pre><code id="code">
const regl = createREGL({ extensions: ['ANGLE_instanced_arrays'] });

// Instantiate a command for drawing lines
const drawLines = reglLines(regl, {
  vert: `
    precision highp float;

    uniform float width, time, phase;
    uniform vec2 aspect;

    #pragma lines: attribute float x;
    #pragma lines: position = torusKnow(x);
    vec4 torusKnow(float x) {
      float theta = ${Math.PI} * x * 2.0;
      const float p = 3.0;
      const float q = 5.0;
      float r = cos(q * theta) + 2.0;
      float phi = p * (theta - phase);
      return vec4(
        vec3(
          aspect * r * vec2(cos(phi), sin(phi)),
          -sin(q * theta)
        ) * 0.25,
        1
      );
    }

    // Return the line width from a uniorm
    #pragma lines: width = getWidth();
    float getWidth() { return width; }`,
  frag: `
    precision highp float;
    uniform float width, borderWidth;
    uniform vec3 color;
    varying vec2 lineCoord;
    void main () {
      // Convert the line coord into an SDF
      float sdf = length(lineCoord) * width;

      // Apply a border with 1px transition
      gl_FragColor = vec4(
        mix(color, vec3(1), smoothstep(width - borderWidth - 0.5, width - borderWidth + 0.5, sdf)),
        1);
    }`,

  // Multiply the width by the pixel ratio for consistent width
  uniforms: {
    aspect: ctx => ctx.viewportWidth > ctx.viewportHeight
      ? [ctx.viewportHeight / ctx.viewportWidth, 1]
      : [1, ctx.viewportWidth / ctx.viewportHeight],
    width: (ctx, props) => ctx.pixelRatio * props.width,
    borderWidth: (ctx, props) => ctx.pixelRatio * props.borderWidth,
    time: regl.context('time'),
    phase: regl.prop('phase'),
    color: regl.prop('color')
  },

  depth: {enable: true}
});

const n = 501;

// Set up the data to be drawn. Note that we preallocate buffers and don't create
// them on every draw call.
const lineData = {
  width: Math.min(window.innerWidth, window.innerHeight) / 20,
  join: 'bevel',
  cap: 'round',
  vertexCount: n + 3,
  vertexAttributes: {
    x: regl.buffer([...Array(n + 3).keys()].map(i => i / n))
  },
  borderWidth: 5
};

function draw() {
  regl.clear({color: [0.2, 0.2, 0.2, 1]});
  drawLines([
    {...lineData, phase: 0, color: [1, 0, 0.5]},
    {...lineData, phase: Math.PI, color: [0, 0.5, 1]},
  ]);
}

draw();
window.addEventListener('resize', draw);

</code></pre>
</details>
</div>
<script>
const code = document.getElementById('code');
hljs.highlightElement(code);
</script>
</body>
</html>
