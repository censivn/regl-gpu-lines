<!DOCTYPE html>
<html>
<head>
  <title>regl-gpu-lines Example</title>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/javascript.min.js"></script>
</head>
<body>
<script src="https://unpkg.com/controls-state@2.0.0/dist/controls-state.min.js"></script>
<script src="https://unpkg.com/controls-gui@2.0.0/dist/controls-gui.min.js"></script>
<script src="https://unpkg.com/regl@2.1.0/dist/regl.js"></script>
<script src="https://unpkg.com/regl-gpu-lines@latest"></script>

<script>
const regl = createREGL({
  pixelRatio: 2,
  extensions: [
    'ANGLE_instanced_arrays',
    'OES_standard_derivatives',
  ],
});

const debug = true;

const state = wrapGUI(State({
    capResolution: State.Slider(21, {min: 1, max: 30, step: 1}),
    joinResolution: State.Slider(8, {min: 1, max: 30, step: 1}),
    cap: State.Select('square', {options: ['round', 'square', 'none']}),
    join: State.Select('round', {options: ['round', 'miter', 'bevel']}),
    lineWidth: State.Slider(60, {min: 1, max: 100, step: 0.1}),
    //borderWidth: State.Slider(10, {min: 0, max: 5, step: 0.1}),
    opacity: State.Slider(0.5, {min: 0, max: 1, step: 0.01}),
    stretch: State.Slider(0.9, {min: 0.01, max: 2, step: 0.01}),
    flip: State.Slider(1, {min: -1, max: 1, step: 0.01}),
    miterLimit: State.Slider(8, {min: 1, max: 8, step: 0.01}),
    //n: State.Slider(11, {min: 3, max: 101, step: 1}),
    depth: false,
    cull: false,
  })
);
state.$onChange(() => draw())
window.addEventListener('resize', () => draw());

const points = [[-0.75, 0.75], [-0.5, 0.5], [-0.25, 0.75], [0.0, -0.7], [0.25, 0.75], [0.5, 0.0], [0.75, 0.75]];
const widths = [1, 2, 1, 2, 1, 2, 1];
const lineData = window.linedata = {
  vertexCount: points.length,
  vertexAttributes: {
    point: regl.buffer(points),
    width: regl.buffer(widths),
  },
  endpointCount: 2,
  endpointAttributes: {
    point: regl.buffer([points.slice(0, 3), points.slice(-3).reverse()]),
    width: regl.buffer([widths.slice(0, 3), widths.slice(-3).reverse()]),
  }
};

const drawLines = reglLines(regl, {
  debug,
  vert: `
    precision highp float;

    #pragma lines: attribute vec2 point;
    #pragma lines: attribute float width;
    #pragma lines: position = project(point);
    #pragma lines: width = getWidth(width);

    uniform float stretch, flip, lineWidth;

    vec4 project (vec2 p) {
      return vec4(p * vec2(pow(stretch, 4.0), flip), 0, 1) - vec4(0.2,0,0,0);
    }

    float getWidth (float width) {
      return lineWidth;
    }`,
  frag: `
    #extension GL_OES_standard_derivatives : enable
    precision mediump float;

    uniform bool squareCap;
    uniform float pixelRatio;
    uniform vec4 borderColor, lineColor;

    varying vec2 lineCoord;
    ${debug ? `
    varying float instanceID;
    varying vec2 triStripGridCoord;
    ` : ''}

    // Unit grid lines
    float grid (vec3 parameter, float width, float feather) {
      float w1 = width - feather * 0.5;
      vec3 d = fwidth(parameter);
      vec3 looped = 0.5 - abs(mod(parameter, 1.0) - 0.5);
      vec3 a3 = smoothstep(d * w1, d * (w1 + feather), looped);
      return min(min(a3.x, a3.y), a3.z);
    }

    void main () {
      float sdf = squareCap ? max(abs(lineCoord.x), abs(lineCoord.y)) : length(lineCoord);

      gl_FragColor.a = lineColor.a;

      ${debug ? `
      if (instanceID < 0.0) {
        // End caps are red
        gl_FragColor.rgb = vec3(0.8, 0.1, 0.4);
      } else {
        // Remaining segments alternate blues
        gl_FragColor.rgb = mod(instanceID, 2.0) == 0.0 ? vec3(0.4, 0.7, 1.0) : vec3(0.2, 0.3, 0.7);
      }
      ` : ''}

      // Invert the border
      bool showBorder = sdf > 0.75 && length(lineColor.rgb - borderColor.rgb) > 0.1;
      if (showBorder) gl_FragColor.rgb = mix(gl_FragColor.rgb, borderColor.rgb, 0.75);

      // Draw a grid
      ${debug ? `
      // Draw unit grid lines and a diagonal line using the vertex ID turned into a vec2 varying.
      //
      //   0     2     4     6     8
      //   + --- + --- + --- + --- +
      //   |   / |   / |   / |   / |
      //   | /   | /   | /   | /   |
      //   + --- + --- + --- + --- +
      //   1     3     5     7     9
      //
      float wire = grid(vec3(triStripGridCoord, triStripGridCoord.x + triStripGridCoord.y), 0.5 * pixelRatio, 1.0);
      gl_FragColor.rgb = mix(vec3(1), gl_FragColor.rgb, wire);
      ` : ''}
    }`
});

const applyCustomConfig = regl({
  uniforms: {
    lineColor: regl.prop('lineColor'),
    borderColor: regl.prop('borderColor'),
    borderWidth: (ctx, props) => [
      (props.lineWidth - props.borderWidth * 2 - 0.5) / props.lineWidth,
      (props.lineWidth - props.borderWidth * 2 + 0.5) / props.lineWidth
    ],
    squareCap: (ctx, props) => props.cap === 'square',
    stretch: regl.prop('stretch'),
    flip: regl.prop('flip'),
    pixelRatio: regl.context('pixelRatio'),
    lineWidth: (ctx, props) => ctx.pixelRatio * props.lineWidth,
    debug: regl.prop('debug'),
  },
  blend: {
    enable: true,
    func: {
      srcRGB: 'src alpha',
      srcAlpha: 1,
      dstRGB: 'one minus src alpha',
      dstAlpha: 1
    }
  },
  cull: {
    enable: (ctx, props) => !!props.cull,
    face: 'back'
  },
  depth: {
    enable: (ctx, props) => !!props.depth
  }
})

function draw () {
  regl.poll();
  regl.clear({color: [0.2, 0.2, 0.2, 1]});

  applyCustomConfig({
    lineColor: [0, 0, 0, state.opacity],
    borderColor: [1, 1, 1, state.opacity],
    ...state
  }, () => {
    drawLines({...lineData, ...state});
  });
}

draw();

</script>
<style>
#code-container {
  font-family: sans-serif;
  position: absolute;
  left: 0;
  z-index: 10;
  max-height: 90%;
  overflow: auto;
  background-color: white;
}
#code-container summary {
  padding: 15px;
  cursor: pointer;
}
</style>
<div id="code-container">
<details>
<summary>Code</summary>
<pre><code id="code">
const regl = createREGL({
  pixelRatio: 2,
  extensions: [
    'ANGLE_instanced_arrays',
    'OES_standard_derivatives',
  ],
});

const debug = true;

const state = wrapGUI(State({
    capResolution: State.Slider(21, {min: 1, max: 30, step: 1}),
    joinResolution: State.Slider(8, {min: 1, max: 30, step: 1}),
    cap: State.Select('square', {options: ['round', 'square', 'none']}),
    join: State.Select('round', {options: ['round', 'miter', 'bevel']}),
    lineWidth: State.Slider(60, {min: 1, max: 100, step: 0.1}),
    //borderWidth: State.Slider(10, {min: 0, max: 5, step: 0.1}),
    opacity: State.Slider(0.5, {min: 0, max: 1, step: 0.01}),
    stretch: State.Slider(0.9, {min: 0.01, max: 2, step: 0.01}),
    flip: State.Slider(1, {min: -1, max: 1, step: 0.01}),
    miterLimit: State.Slider(8, {min: 1, max: 8, step: 0.01}),
    //n: State.Slider(11, {min: 3, max: 101, step: 1}),
    depth: false,
    cull: false,
  })
);
state.$onChange(() => draw())
window.addEventListener('resize', () => draw());

const points = [[-0.75, 0.75], [-0.5, 0.5], [-0.25, 0.75], [0.0, -0.7], [0.25, 0.75], [0.5, 0.0], [0.75, 0.75]];
const widths = [1, 2, 1, 2, 1, 2, 1];
const lineData = window.linedata = {
  vertexCount: points.length,
  vertexAttributes: {
    point: regl.buffer(points),
    width: regl.buffer(widths),
  },
  endpointCount: 2,
  endpointAttributes: {
    point: regl.buffer([points.slice(0, 3), points.slice(-3).reverse()]),
    width: regl.buffer([widths.slice(0, 3), widths.slice(-3).reverse()]),
  }
};

const drawLines = reglLines(regl, {
  debug,
  vert: `
    precision highp float;

    #pragma lines: attribute vec2 point;
    #pragma lines: attribute float width;
    #pragma lines: position = project(point);
    #pragma lines: width = getWidth(width);

    uniform float stretch, flip, lineWidth;

    vec4 project (vec2 p) {
      return vec4(p * vec2(pow(stretch, 4.0), flip), 0, 1) - vec4(0.2,0,0,0);
    }

    float getWidth (float width) {
      return lineWidth;
    }`,
  frag: `
    #extension GL_OES_standard_derivatives : enable
    precision mediump float;

    uniform bool squareCap;
    uniform float pixelRatio;
    uniform vec4 borderColor, lineColor;

    varying vec2 lineCoord;
    ${debug ? `
    varying float instanceID;
    varying vec2 triStripGridCoord;
    ` : ''}

    // Unit grid lines
    float grid (vec3 parameter, float width, float feather) {
      float w1 = width - feather * 0.5;
      vec3 d = fwidth(parameter);
      vec3 looped = 0.5 - abs(mod(parameter, 1.0) - 0.5);
      vec3 a3 = smoothstep(d * w1, d * (w1 + feather), looped);
      return min(min(a3.x, a3.y), a3.z);
    }

    void main () {
      float sdf = squareCap ? max(abs(lineCoord.x), abs(lineCoord.y)) : length(lineCoord);

      gl_FragColor.a = lineColor.a;

      ${debug ? `
      if (instanceID < 0.0) {
        // End caps are red
        gl_FragColor.rgb = vec3(0.8, 0.1, 0.4);
      } else {
        // Remaining segments alternate blues
        gl_FragColor.rgb = mod(instanceID, 2.0) == 0.0 ? vec3(0.4, 0.7, 1.0) : vec3(0.2, 0.3, 0.7);
      }
      ` : ''}

      // Invert the border
      bool showBorder = sdf > 0.75 && length(lineColor.rgb - borderColor.rgb) > 0.1;
      if (showBorder) gl_FragColor.rgb = mix(gl_FragColor.rgb, borderColor.rgb, 0.75);

      // Draw a grid
      ${debug ? `
      // Draw unit grid lines and a diagonal line using the vertex ID turned into a vec2 varying.
      //
      //   0     2     4     6     8
      //   + --- + --- + --- + --- +
      //   |   / |   / |   / |   / |
      //   | /   | /   | /   | /   |
      //   + --- + --- + --- + --- +
      //   1     3     5     7     9
      //
      float wire = grid(vec3(triStripGridCoord, triStripGridCoord.x + triStripGridCoord.y), 0.5 * pixelRatio, 1.0);
      gl_FragColor.rgb = mix(vec3(1), gl_FragColor.rgb, wire);
      ` : ''}
    }`
});

const applyCustomConfig = regl({
  uniforms: {
    lineColor: regl.prop('lineColor'),
    borderColor: regl.prop('borderColor'),
    borderWidth: (ctx, props) => [
      (props.lineWidth - props.borderWidth * 2 - 0.5) / props.lineWidth,
      (props.lineWidth - props.borderWidth * 2 + 0.5) / props.lineWidth
    ],
    squareCap: (ctx, props) => props.cap === 'square',
    stretch: regl.prop('stretch'),
    flip: regl.prop('flip'),
    pixelRatio: regl.context('pixelRatio'),
    lineWidth: (ctx, props) => ctx.pixelRatio * props.lineWidth,
    debug: regl.prop('debug'),
  },
  blend: {
    enable: true,
    func: {
      srcRGB: 'src alpha',
      srcAlpha: 1,
      dstRGB: 'one minus src alpha',
      dstAlpha: 1
    }
  },
  cull: {
    enable: (ctx, props) => !!props.cull,
    face: 'back'
  },
  depth: {
    enable: (ctx, props) => !!props.depth
  }
})

function draw () {
  regl.poll();
  regl.clear({color: [0.2, 0.2, 0.2, 1]});

  applyCustomConfig({
    lineColor: [0, 0, 0, state.opacity],
    borderColor: [1, 1, 1, state.opacity],
    ...state
  }, () => {
    drawLines({...lineData, ...state});
  });
}

draw();

</code></pre>
</details>
</div>
<script>
const code = document.getElementById('code');
hljs.highlightElement(code);
</script>
</body>
</html>
